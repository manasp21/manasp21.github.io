{
  "https://github.com/manasp21/rabi-mcp": {
    "name": "rabi-mcp",
    "full_name": "manasp21/rabi-mcp",
    "description": "Advanced MCP server specialized in Atomic, Molecular and Optical (AMO) Physics",
    "readme_description": "Advanced MCP server specialized in Atomic, Molecular and Optical (AMO) Physics Rabi MCP Server is a comprehensive Model Context Protocol (MCP) server that brings cutting-edge quantum physics simula...",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-06-26T06:21:28Z",
    "updated_at": "2025-06-26T19:14:06Z",
    "pushed_at": "2025-06-26T18:52:41Z",
    "size": 134,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/rabi-mcp",
    "clone_url": "https://github.com/manasp21/rabi-mcp.git",
    "ssh_url": "git@github.com:manasp21/rabi-mcp.git",
    "readme_content": "# üî¨ Rabi MCP Server\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Python 3.8+](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)\n[![Docker](https://img.shields.io/badge/docker-available-blue.svg)](https://hub.docker.com/)\n[![Smithery](https://img.shields.io/badge/smithery-deployable-green.svg)](https://smithery.ai/)\n\n**Advanced MCP server specialized in Atomic, Molecular and Optical (AMO) Physics**\n\nRabi MCP Server is a comprehensive Model Context Protocol (MCP) server that brings cutting-edge quantum physics simulations and analysis tools to Claude and other AI assistants. Named after the Rabi oscillations fundamental to quantum optics, this server provides an extensive suite of tools for simulating quantum systems, analyzing spectroscopic data, and visualizing complex AMO physics phenomena.\n\n## ‚ú® Features\n\n### üî¨ Quantum Systems Simulation\n- **Two-level atoms**: Rabi oscillations, Bloch vector dynamics, spontaneous emission\n- **Multi-level systems**: Arbitrary energy level structures, complex transition networks\n- **Time evolution**: Schr√∂dinger equation solvers, master equation dynamics\n- **Open quantum systems**: Lindblad equations, quantum trajectories\n\n### üìä Spectroscopy & Analysis\n- **Absorption spectra**: Natural, Doppler, and collisional broadening\n- **Line shapes**: Lorentzian, Gaussian, and Voigt profiles\n- **Strong-field physics**: Tunneling ionization, multiphoton processes\n- **High harmonic generation**: Laser-atom interaction analysis\n\n### ‚ùÑÔ∏è Cold Atoms & Quantum Gases\n- **Bose-Einstein condensates**: Gross-Pitaevskii equation solver\n- **Optical lattices**: Band structure calculations, tight-binding models\n- **Magnetic trapping**: Harmonic and anharmonic potentials\n- **Quantum phase transitions**: Critical phenomena in ultracold gases\n\n### üåà Quantum Optics\n- **Cavity QED**: Jaynes-Cummings model, strong coupling regime\n- **Photon statistics**: g¬≤(œÑ) correlations, antibunching detection\n- **Quantum entanglement**: Bell states, entanglement measures\n- **Quantum metrology**: Squeezed states, precision measurements\n\n### üìà Advanced Visualizations\n- **3D Bloch sphere**: Interactive quantum state visualization\n- **Population dynamics**: Real-time evolution plots\n- **Spectrograms**: Time-frequency analysis\n- **Phase space plots**: Wigner functions, Husimi Q-functions\n\n## üì¶ Installation Methods\n\nChoose your preferred installation method below. All methods give you access to the same powerful AMO physics tools.\n\n### üöÄ Method 1: One-Line Auto-Install (Recommended)\n\n**The fastest way to get started:**\n\n```bash\ncurl -sSL https://raw.githubusercontent.com/manasp21/rabi-mcp/main/scripts/install.sh | bash\n```\n\n**What this does:**\n- ‚úÖ Checks system requirements (Python 3.8+, Git)\n- ‚úÖ Installs system dependencies (gcc, gfortran, BLAS/LAPACK)\n- ‚úÖ Sets up isolated Python virtual environment\n- ‚úÖ Installs all physics dependencies (NumPy, SciPy, QuTiP, etc.)\n- ‚úÖ Configures Claude Desktop integration automatically\n- ‚úÖ Creates convenient startup commands\n- ‚úÖ Runs comprehensive tests\n\n**Test the installation:**\n```bash\n# Check server functionality\n~/.rabi-mcp/start-server.sh --test\n\n# Or use the command if ~/.local/bin is in PATH\nrabi-mcp-server --test\n```\n\n---\n\n### ‚òÅÔ∏è Method 2: Smithery Cloud (Zero Setup)\n\n**Deploy directly to the cloud with one command:**\n\n```bash\n# Install Smithery CLI\nnpm install -g @smithery/cli\n\n# Deploy to Smithery cloud (REQUIRED FIRST STEP)\nnpx @smithery/cli deploy https://github.com/manasp21/rabi-mcp.git\n```\n\n**‚ö†Ô∏è Important: Deploy First!**\nThe server URL `https://server.smithery.ai/@manasp21/rabi-mcp` will only become accessible **after** successful deployment. If you see \"401 Unauthorized\" or connection timeouts, it means the server hasn't been deployed yet.\n\n**What you get:**\n- ‚úÖ Instant cloud deployment (no local setup needed)\n- ‚úÖ Automatic scaling and resource management\n- ‚úÖ Built-in configuration management\n- ‚úÖ Web-based tool inspection and testing\n- ‚úÖ Integration with Claude and other AI assistants\n\n**Deployment Process:**\n1. **Deploy**: Run the deploy command above\n2. **Wait**: Deployment typically takes 2-5 minutes\n3. **Verify**: Check deployment status in Smithery dashboard\n4. **Test**: Server will be accessible once deployment completes\n\n**Test on Smithery:**\n1. Go to [Smithery Dashboard](https://smithery.ai/)\n2. Wait for deployment status to show \"Running\"\n3. Find your deployed `rabi-mcp-server`\n4. Click \"Connect\" to test tools\n5. Try running: `simulate_two_level_atom` with sample parameters\n\n**Troubleshooting:**\n- **\"401 Unauthorized\"**: Server not deployed yet - run deploy command first\n- **\"Connection timeout\"**: Server still building - wait a few more minutes\n- **\"Please configure server\"**: Deployment failed - check build logs in dashboard\n\n---\n\n### üê≥ Method 3: Docker (Containerized)\n\n**Run in an isolated container environment:**\n\n#### Quick Start:\n```bash\n# Pull and run the pre-built image\ndocker run --name rabi-mcp -it manasp21/rabi-mcp-server:latest\n```\n\n#### Build from Source:\n```bash\n# Clone repository\ngit clone https://github.com/manasp21/rabi-mcp.git\ncd rabi-mcp\n\n# Build and run with Docker Compose\ndocker-compose up --build\n\n# Or build manually\ndocker build -t rabi-mcp-server .\ndocker run -it rabi-mcp-server\n```\n\n#### For Development:\n```bash\n# Run with volume mounting for live code changes\ndocker run -it \\\n  -v $(pwd)/src:/app/src \\\n  -v $(pwd)/tests:/app/tests \\\n  manasp21/rabi-mcp-server:latest\n```\n\n**Test Docker deployment:**\n```bash\n# Test container is working\ndocker exec -it rabi-mcp python test_mcp_server.py\n\n# Run physics calculations\ndocker exec -it rabi-mcp python -c \"\nfrom src.tools.quantum_systems import simulate_two_level_atom\nimport asyncio\nresult = asyncio.run(simulate_two_level_atom(1e6, 0, 1e-6))\nprint('Docker test passed!' if result['success'] else 'Test failed')\n\"\n```\n\n---\n\n### üõ†Ô∏è Method 4: Manual Installation (Full Control)\n\n**For developers and advanced users:**\n\n#### Prerequisites:\n```bash\n# Ubuntu/Debian\nsudo apt update && sudo apt install -y \\\n  python3.8+ python3-pip python3-venv git \\\n  gcc g++ gfortran libopenblas-dev liblapack-dev libfftw3-dev\n\n# macOS (with Homebrew)\nbrew install python@3.11 gcc gfortran openblas fftw git\n\n# CentOS/RHEL\nsudo yum install -y python3 python3-pip git gcc gcc-gfortran \\\n  openblas-devel lapack-devel fftw-devel\n```\n\n#### Installation Steps:\n```bash\n# 1. Clone the repository\ngit clone https://github.com/manasp21/rabi-mcp.git\ncd rabi-mcp\n\n# 2. Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# 3. Install dependencies\npip install --upgrade pip setuptools wheel\npip install -r requirements.txt\npip install -e .\n\n# 4. Test installation\npython test_mcp_server.py\n\n# 5. Start the server\npython -m src.mcp_server\n```\n\n**Test manual installation:**\n```bash\n# Activate environment\nsource venv/bin/activate\n\n# Run comprehensive tests\npytest tests/ -v\n\n# Test a quantum simulation\npython -c \"\nimport asyncio\nfrom src.tools.quantum_systems import rabi_oscillations\n\nasync def test():\n    result = await rabi_oscillations(\n        rabi_frequency=2*3.14159*1e6,  # 1 MHz\n        max_time=1e-6,                 # 1 Œºs\n        time_points=100\n    )\n    print(f'Rabi oscillations test: {\\\"PASSED\\\" if result[\\\"success\\\"] else \\\"FAILED\\\"}')\n    return result['success']\n\nsuccess = asyncio.run(test())\nprint('Manual installation verified!' if success else 'Test failed!')\n\"\n```\n\n---\n\n### üñ•Ô∏è Method 5: Claude Desktop Integration\n\n**Add directly to Claude Desktop for seamless use:**\n\n#### Automatic Setup (after auto-install):\nIf you used Method 1, Claude Desktop is already configured! Just restart Claude Desktop.\n\n#### Manual Setup:\n1. **Find your Claude config directory:**\n   - **Windows**: `%APPDATA%\\Claude\\`\n   - **macOS**: `~/Library/Application Support/Claude/`\n   - **Linux**: `~/.config/claude/`\n\n2. **Edit `claude_desktop_config.json`:**\n```json\n{\n  \"mcpServers\": {\n    \"rabi-mcp\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"src.mcp_server\"],\n      \"env\": {\n        \"PYTHONPATH\": \"/path/to/rabi-mcp\"\n      }\n    }\n  }\n}\n```\n\n3. **Or use installed version:**\n```json\n{\n  \"mcpServers\": {\n    \"rabi-mcp\": {\n      \"command\": \"/home/user/.rabi-mcp/venv/bin/python\",\n      \"args\": [\"-m\", \"src.mcp_server\"],\n      \"env\": {\n        \"PYTHONPATH\": \"/home/user/.rabi-mcp/source\"\n      }\n    }\n  }\n}\n```\n\n**Test Claude Desktop integration:**\n1. Restart Claude Desktop\n2. Start a new conversation\n3. Type: \"Can you simulate Rabi oscillations for a two-level atom?\"\n4. Claude should automatically use the physics tools\n\n---\n\n### üì± Method 6: VS Code Extension\n\n**For development with full IDE support:**\n\n```bash\n# Install the MCP VS Code extension\ncode --install-extension mcp.mcp-tools\n\n# Configure workspace settings\necho '{\n  \"mcp.servers\": {\n    \"rabi-mcp\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"src.mcp_server\"],\n      \"cwd\": \"'$(pwd)'\"\n    }\n  }\n}' > .vscode/settings.json\n```\n\n---\n\n### üêç Method 7: Python Package Installation\n\n**Install as a Python package:**\n\n```bash\n# From PyPI (when published)\npip install rabi-mcp-server\n\n# Or install from GitHub\npip install git+https://github.com/manasp21/rabi-mcp.git\n\n# Run as module\npython -m rabi_mcp_server\n\n# Or use entry point\nrabi-mcp-server\n```\n\n**Test package installation:**\n```python\nimport rabi_mcp_server\nfrom rabi_mcp_server.tools import quantum_systems\nprint(\"Package installation successful!\")\n```\n\n---\n\n## üß™ Testing Your Installation\n\n### Quick Test Script\n\nRun this after any installation method:\n\n```python\n#!/usr/bin/env python3\n\"\"\"Quick test of Rabi MCP Server installation.\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# Add to path if needed\nsys.path.insert(0, str(Path(__file__).parent / \"src\"))\n\nasync def quick_test():\n    \"\"\"Test basic functionality.\"\"\"\n    try:\n        from src.tools.quantum_systems import simulate_two_level_atom\n        \n        print(\"üî¨ Testing Rabi MCP Server...\")\n        \n        # Test Rabi oscillations\n        result = await simulate_two_level_atom(\n            rabi_frequency=2*3.14159*1e6,  # 1 MHz\n            detuning=0,                     # On resonance\n            evolution_time=1e-6,            # 1 Œºs\n            initial_state=\"ground\"\n        )\n        \n        if result[\"success\"]:\n            print(\"‚úÖ Two-level atom simulation: PASSED\")\n            print(f\"   Max excited population: {result['summary']['max_excited_population']:.3f}\")\n            \n            # Test BEC simulation\n            from src.tools.cold_atoms import bec_simulation\n            bec_result = await bec_simulation(\n                grid_size=64,\n                box_length=10,      # Œºm\n                particle_number=1000,\n                scattering_length=100,  # nm\n                trap_frequency=100,     # Hz\n                evolution_time=1        # ms\n            )\n            \n            if bec_result[\"success\"]:\n                print(\"‚úÖ BEC simulation: PASSED\")\n                print(f\"   Healing length: {bec_result['characteristic_scales']['healing_length_um']:.2f} Œºm\")\n            else:\n                print(\"‚ùå BEC simulation: FAILED\")\n                \n            # Test spectroscopy\n            from src.tools.spectroscopy import absorption_spectrum\n            spec_result = await absorption_spectrum(\n                transition_frequency=2.4e15,  # rad/s (D2 line)\n                linewidth=6e6,                # rad/s\n                frequency_range=[2.39e15, 2.41e15]\n            )\n            \n            if spec_result[\"success\"]:\n                print(\"‚úÖ Spectroscopy analysis: PASSED\")\n                print(f\"   Peak wavelength: {spec_result['analysis']['peak_wavelength_nm']:.1f} nm\")\n            else:\n                print(\"‚ùå Spectroscopy analysis: FAILED\")\n                \n            print(\"\\nüéâ Installation test completed successfully!\")\n            print(\"üöÄ Rabi MCP Server is ready for advanced AMO physics!\")\n            return True\n            \n        else:\n            print(f\"‚ùå Test failed: {result.get('error', 'Unknown error')}\")\n            return False\n            \n    except Exception as e:\n        print(f\"‚ùå Installation test failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\nif __name__ == \"__main__\":\n    success = asyncio.run(quick_test())\n    sys.exit(0 if success else 1)\n```\n\nSave as `test_installation.py` and run:\n```bash\npython test_installation.py\n```\n\n### Comprehensive Test Suite\n\nFor thorough testing:\n\n```bash\n# Run all physics tests\npytest tests/ -v\n\n# Test specific modules\npytest tests/test_quantum_systems.py -v\npytest tests/test_spectroscopy.py -v\n\n# Test with coverage\npytest --cov=src tests/\n\n# Performance benchmarks\npython -m pytest tests/ --benchmark-only\n```\n\n### Tool-by-Tool Testing\n\nTest individual physics tools:\n\n```bash\n# Test quantum systems\npython -c \"\nimport asyncio\nfrom src.tools import quantum_systems\nasyncio.run(quantum_systems.simulate_two_level_atom(1e6, 0, 1e-6))\n\"\n\n# Test spectroscopy\npython -c \"\nimport asyncio\nfrom src.tools import spectroscopy\nasyncio.run(spectroscopy.absorption_spectrum(2e15, 1e6, [1.9e15, 2.1e15]))\n\"\n\n# Test cold atoms\npython -c \"\nimport asyncio\nfrom src.tools import cold_atoms\nasyncio.run(cold_atoms.bec_simulation(64, 10, 1000, 100, 100, 1))\n\"\n\n# Test quantum optics\npython -c \"\nimport asyncio\nfrom src.tools import quantum_optics\nasyncio.run(quantum_optics.cavity_qed(1e6, 2e14, 2e14, 10))\n\"\n```\n\n## üîß Configuration\n\n### Environment Variables\n```bash\n# Computational settings\nexport COMPUTATIONAL_BACKEND=numpy  # Options: numpy, jax, numba\nexport MAX_HILBERT_DIM=1000\nexport ENABLE_GPU=false\nexport PRECISION=double\nexport ENABLE_PARALLEL=true\n\n# Performance tuning\nexport NUM_THREADS=4\nexport MEMORY_LIMIT_GB=8\nexport CACHE_RESULTS=true\n\n# Logging\nexport LOG_LEVEL=INFO\nexport ENABLE_PERFORMANCE_LOGGING=true\n```\n\n### Configuration File\nCreate `.env` file in your installation directory:\n```env\n# Rabi MCP Server Configuration\nCOMPUTATIONAL_BACKEND=numpy\nMAX_HILBERT_DIM=1000\nENABLE_GPU=false\nPRECISION=double\nENABLE_PARALLEL=true\nCACHE_RESULTS=true\nNUM_THREADS=4\nLOG_LEVEL=INFO\n```\n\n## üöÄ Usage Examples\n\n### Basic Quantum Simulation\n```python\n# Rabi oscillations\nawait mcp_client.call_tool(\"rabi_oscillations\", {\n    \"rabi_frequency\": 1e6,    # 1 MHz\n    \"max_time\": 1e-5,         # 10 Œºs\n    \"time_points\": 1000\n})\n```\n\n### Advanced BEC Simulation\n```python\n# Gross-Pitaevskii equation\nawait mcp_client.call_tool(\"bec_simulation\", {\n    \"grid_size\": 256,\n    \"box_length\": 50,         # Œºm\n    \"particle_number\": 50000,\n    \"scattering_length\": 100, # nm\n    \"trap_frequency\": 50,     # Hz\n    \"evolution_time\": 100     # ms\n})\n```\n\n### Spectroscopy Analysis\n```python\n# Doppler-broadened absorption\nawait mcp_client.call_tool(\"absorption_spectrum\", {\n    \"transition_frequency\": 2.4e15,\n    \"linewidth\": 6e6,\n    \"frequency_range\": [2.39e15, 2.41e15],\n    \"broadening_type\": \"doppler\",\n    \"temperature\": 300,\n    \"atomic_mass\": 87\n})\n```\n\n### Interactive Visualization\n```python\n# 3D Bloch sphere\nawait mcp_client.call_tool(\"plot_bloch_sphere\", {\n    \"state_vector\": [0.707, 0, 0.707, 0],  # |+‚ü© state\n    \"show_trajectory\": true,\n    \"title\": \"Superposition State\"\n})\n```\n\n## üõ†Ô∏è Available Tools\n\n### Quantum Systems (8 tools)\n- `simulate_two_level_atom` - Two-level atom dynamics\n- `rabi_oscillations` - Rabi frequency analysis\n- `multi_level_atom` - Complex atomic systems\n- `bloch_dynamics` - Bloch vector evolution\n- `master_equation` - Open quantum systems\n- `quantum_trajectories` - Stochastic evolution\n- `coherent_control` - Optimal control sequences\n- `adiabatic_evolution` - Slow parameter changes\n\n### Spectroscopy (6 tools)\n- `absorption_spectrum` - Absorption line analysis\n- `emission_spectrum` - Fluorescence and emission\n- `laser_atom_interaction` - Strong-field physics\n- `doppler_broadening` - Temperature effects\n- `stark_shift` - Electric field effects\n- `zeeman_effect` - Magnetic field splitting\n\n### Cold Atoms (5 tools)\n- `bec_simulation` - Bose-Einstein condensates\n- `optical_lattice` - Band structure calculations\n- `magnetic_trapping` - Trap design and analysis\n- `evaporative_cooling` - Cooling dynamics\n- `quantum_gas_transport` - Non-equilibrium dynamics\n\n### Quantum Optics (6 tools)\n- `cavity_qed` - Jaynes-Cummings dynamics\n- `photon_statistics` - g¬≤(œÑ) correlations\n- `squeezed_states` - Non-classical light\n- `entanglement_analysis` - Bell states and measures\n- `quantum_interferometry` - Precision measurements\n- `parametric_amplification` - Nonlinear optics\n\n### Visualization (8+ tools)\n- `plot_bloch_sphere` - 3D quantum state visualization\n- `plot_population_dynamics` - Time evolution plots\n- `plot_spectrum` - Spectroscopic data\n- `plot_wigner_function` - Phase space distributions\n- `plot_correlation_functions` - Quantum correlations\n- `animate_evolution` - Time-dependent animations\n- `interactive_dashboard` - Real-time parameter control\n\n### Utilities (5+ tools)\n- `unit_conversion` - Physics unit conversions\n- `physical_constants` - Fundamental constants lookup\n- `data_analysis` - Fitting and statistics\n- `experimental_parameters` - Lab calculation helpers\n- `literature_lookup` - Physics reference data\n\n## üìö Documentation\n\n- [**API Reference**](docs/api.md) - Complete tool documentation\n- [**Physics Guide**](docs/physics_guide.md) - Theoretical background\n- [**Examples**](docs/examples/) - Worked physics examples\n- [**Configuration**](docs/configuration.md) - Advanced setup options\n- [**Contributing**](CONTRIBUTING.md) - Development guidelines\n- [**FAQ**](docs/faq.md) - Common questions and troubleshooting\n\n## ü§ù Contributing\n\nWe welcome contributions from the AMO physics community!\n\n```bash\n# Development setup\ngit clone https://github.com/manasp21/rabi-mcp.git\ncd rabi-mcp\npython -m venv venv\nsource venv/bin/activate\npip install -e \".[dev]\"\npre-commit install\n\n# Run tests\npytest tests/ -v\n\n# Submit a pull request\ngit checkout -b feature/new-physics-tool\n# ... make changes ...\ngit commit -m \"Add new quantum simulation tool\"\ngit push origin feature/new-physics-tool\n```\n\n## üìÑ License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## üôè Acknowledgments\n\n- **QuTiP Team**: Quantum Toolbox in Python\n- **NumPy/SciPy**: Scientific computing foundation\n- **MCP Protocol**: Model Context Protocol standard\n- **AMO Physics Community**: Theoretical foundations\n\n## üìû Support & Community\n\n- **Issues**: [GitHub Issues](https://github.com/manasp21/rabi-mcp/issues)\n- **Discussions**: [GitHub Discussions](https://github.com/manasp21/rabi-mcp/discussions)\n- **Discord**: [AMO Physics MCP Community](https://discord.gg/amo-physics-mcp)\n- **Email**: [manasp21@example.com](mailto:manasp21@example.com)\n\n---\n\n<div align=\"center\">\n\n**üî¨ Built with ‚ù§Ô∏è for the AMO physics community ‚öõÔ∏è**\n\n[üöÄ Get Started](https://github.com/manasp21/rabi-mcp) ‚Ä¢ [üìñ Documentation](docs/) ‚Ä¢ [üî¨ Examples](docs/examples/) ‚Ä¢ [üí¨ Community](https://discord.gg/amo-physics-mcp)\n\n</div>",
    "cached_at": 1750965281.2648373
  },
  "https://github.com/manasp21/MagTrace": {
    "name": "MagTrace",
    "full_name": "manasp21/MagTrace",
    "description": "Professional magnetic field analysis platform for research and industrial applications",
    "readme_description": "Professional magnetic field analysis platform for research and industrial applications Author: Manas Pandey | Developed with Claude AI assistance",
    "language": "Python",
    "stars": 1,
    "forks": 0,
    "watchers": 1,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-06-05T05:45:52Z",
    "updated_at": "2025-06-24T13:28:21Z",
    "pushed_at": "2025-06-17T14:12:08Z",
    "size": 15940,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/MagTrace",
    "clone_url": "https://github.com/manasp21/MagTrace.git",
    "ssh_url": "git@github.com:manasp21/MagTrace.git",
    "readme_content": "# MagTrace - Magnetic Field Data Analysis Platform\n\n**Professional magnetic field analysis platform for research and industrial applications**\n\n*Author: Manas Pandey | Developed with Claude AI assistance*\n\n[![Python](https://img.shields.io/badge/python-3.8+-blue.svg)](https://python.org)\n[![Django](https://img.shields.io/badge/django-4.2-green.svg)](https://djangoproject.com)\n[![Status](https://img.shields.io/badge/status-development-orange.svg)](#current-limitations)\n\n## Project Status: Development Phase\n\n**Current State:** Core functionality implemented, requires comprehensive testing and production hardening.\n\nMagTrace provides magnetic field data analysis capabilities using machine learning for anomaly detection and pattern recognition. The platform processes magnetometer sensor data (B_x, B_y, B_z components) with interactive visualization and automated classification.\n\n## Quick Start\n\n```bash\ngit clone https://github.com/manasp21/MagTrace.git\ncd MagTrace\npython3 run.py\n```\n\n**Access Points:**\n- **Main Application:** http://localhost:8000/app/\n- **API Documentation:** http://localhost:8000/api/\n- **Health Check:** http://localhost:8000/health/\n\n## Core Features (Implemented)\n\n### ‚úÖ Working Functionality\n- **Project Management** - Organize magnetic field analysis projects\n- **CSV Data Upload** - Process magnetometer readings with automatic parsing\n- **Interactive Visualization** - D3.js charts with zoom, pan, and brush selection\n- **Data Labeling** - Manual annotation of magnetic field anomalies and patterns\n- **Machine Learning Training** - Scikit-learn Random Forest classification\n- **Real-time Progress** - Live training monitoring with progress indicators\n- **RESTful API** - Complete API for programmatic access\n\n### üìä Data Format Support\n```csv\ntimestamp_pc,b_x,b_y,b_z,lat,lon,altitude,thetax,thetay,thetaz,sensor_id\n24:40.0,7746.664,9395.448,14682.022,26.5123251,80.2238068,2018,0,0,0,S963350075783\n```\n\n**Required Columns:** `timestamp_pc`, `b_x`, `b_y`, `b_z`\n**Optional Columns:** `lat`, `lon`, `altitude`, `sensor_id`, `thetax`, `thetay`, `thetaz`\n\n## Current Limitations\n\n### üö® Critical Production Gaps\n\n**1. Security**\n- ‚ùå **No authentication system** - Single-user development setup only\n- ‚ùå **No input validation** - Limited CSV format checking\n- ‚ùå **No rate limiting** - API endpoints unprotected\n- ‚ùå **Insecure file uploads** - Basic validation only\n- ‚ùå **Debug mode enabled** - Not production-ready\n\n**2. Scalability Issues**\n- ‚ùå **SQLite database** - Single-user, no concurrent access\n- ‚ùå **File upload limits** - ~100MB maximum, no chunking\n- ‚ùå **Memory limitations** - Large datasets (>50k points) cause performance issues\n- ‚ùå **No background processing** - Training blocks server threads\n- ‚ùå **Single-threaded ML** - No distributed computing support\n\n**3. Data Management**\n- ‚ùå **No data validation** - Limited error handling for malformed CSV\n- ‚ùå **No backup system** - Manual database backup required\n- ‚ùå **No data retention** - Unlimited storage consumption\n- ‚ùå **No audit logging** - No tracking of data access or modifications\n\n**4. Reliability**\n- ‚ùå **No error recovery** - Failed operations require manual cleanup\n- ‚ùå **No monitoring** - No health checks or alerting\n- ‚ùå **Development server** - Django development server not production-ready\n- ‚ùå **No load balancing** - Single point of failure\n\n## Testing Requirements\n\n### üß™ Comprehensive Testing Needed\n\n**CRITICAL:** This system requires extensive testing before any production deployment.\n\n#### Performance Testing\n- [ ] **Small datasets** (< 1,000 points) - Response time < 2 seconds\n- [ ] **Medium datasets** (1,000-10,000 points) - Memory usage < 2GB\n- [ ] **Large datasets** (> 10,000 points) - Verify decimation works correctly\n- [ ] **Concurrent users** - Test multiple simultaneous uploads\n- [ ] **Memory stress** - Monitor for memory leaks during extended use\n\n#### Functional Testing  \n- [ ] **End-to-end workflow** - Project ‚Üí Upload ‚Üí Label ‚Üí Train ‚Üí Predict\n- [ ] **API endpoints** - All CRUD operations for each model\n- [ ] **Error handling** - Invalid data, network failures, timeouts\n- [ ] **Browser compatibility** - Chrome, Firefox, Safari, Edge\n- [ ] **Data integrity** - Verify annotations persist correctly\n\n#### Security Testing\n- [ ] **Input validation** - SQL injection, XSS, file upload attacks\n- [ ] **CSRF protection** - Verify all state-changing operations protected\n- [ ] **File upload security** - Malicious file upload attempts\n- [ ] **API security** - Authentication bypass attempts\n\n#### Data Quality Testing\n- [ ] **CSV format variations** - Different timestamp formats, missing columns\n- [ ] **Magnetic field ranges** - Extreme values, negative numbers, scientific notation\n- [ ] **GPS coordinates** - Invalid lat/lon values, missing location data\n- [ ] **Large file handling** - Files approaching 100MB limit\n\n### Test Data Requirements\n\n**Minimum Test Dataset Collection:**\n1. **Small datasets** (10-100 points) - Quick validation\n2. **Medium datasets** (1,000-5,000 points) - Performance testing  \n3. **Large datasets** (10,000+ points) - Stress testing\n4. **Anomaly datasets** - Clear patterns for ML validation\n5. **Edge case datasets** - Missing values, extreme ranges, malformed data\n\n**Sample data provided:** `example/data_1.csv` (46 points) - Insufficient for comprehensive testing.\n\n## Technical Architecture\n\n### Backend Stack\n- **Framework:** Django 4.2 + Django REST Framework\n- **Database:** SQLite (development) / PostgreSQL (production required)\n- **ML Framework:** Scikit-learn 1.3.2 (TensorFlow optional, often fails)\n- **File Processing:** Pandas for CSV parsing and data manipulation\n\n### Frontend Stack  \n- **UI:** HTML5 + Vanilla JavaScript + CSS\n- **Visualization:** D3.js for interactive magnetic field charts\n- **AJAX:** Fetch API for backend communication\n\n### Key Components\n```\nbackend/\n‚îú‚îÄ‚îÄ magtrace_api/               # Main API application\n‚îÇ   ‚îú‚îÄ‚îÄ models.py              # Database models (Project, Dataset, Annotation)\n‚îÇ   ‚îú‚îÄ‚îÄ views.py               # API endpoints and business logic\n‚îÇ   ‚îú‚îÄ‚îÄ simple_training_service.py   # ML training orchestration\n‚îÇ   ‚îî‚îÄ‚îÄ serializers.py         # API data serialization\n‚îú‚îÄ‚îÄ templates/magtrace.html    # Single-page application interface\n‚îú‚îÄ‚îÄ static/js/magtrace.js      # Frontend application logic\n‚îî‚îÄ‚îÄ manage.py                  # Django management commands\n```\n\n## Production Deployment Requirements\n\n### üè≠ Production Checklist\n\n**Infrastructure:**\n- [ ] **Web Server** - Nginx/Apache with WSGI (Gunicorn/uWSGI)\n- [ ] **Database** - PostgreSQL with connection pooling\n- [ ] **Caching** - Redis for session storage and API caching\n- [ ] **File Storage** - S3/MinIO for uploaded datasets (not local filesystem)\n- [ ] **Monitoring** - Application performance monitoring (APM)\n\n**Security Hardening:**\n- [ ] **Authentication** - User management system with role-based access\n- [ ] **HTTPS** - SSL certificate and secure headers\n- [ ] **Input Validation** - Comprehensive data sanitization\n- [ ] **Rate Limiting** - API request throttling\n- [ ] **File Upload Security** - Virus scanning, type validation\n\n**Scalability:**\n- [ ] **Background Jobs** - Celery + Redis for ML training\n- [ ] **Load Balancing** - Multiple application instances\n- [ ] **Database Scaling** - Read replicas, connection pooling\n- [ ] **CDN** - Static file delivery optimization\n\n**Operational:**\n- [ ] **Backup Strategy** - Automated database and file backups\n- [ ] **Logging** - Structured application and access logs\n- [ ] **Monitoring** - Health checks, error tracking, alerting\n- [ ] **Deployment Pipeline** - CI/CD with automated testing\n\n## Development Setup\n\n### Prerequisites\n- Python 3.8+ (3.10+ recommended)\n- 8GB+ RAM (for large dataset processing)\n- Modern web browser\n\n### Installation Options\n\n**1. Quick Start (Recommended)**\n```bash\npython3 run.py  # Automated setup with virtual environment\n```\n\n**2. Manual Setup**\n```bash\ncd backend\npython3 -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Use lightweight requirements (TensorFlow often fails)\npip install -r requirements-lite.txt\n\npython manage.py migrate\npython manage.py runserver\n```\n\n### Verification\n```bash\n# Health check\ncurl http://localhost:8000/health/\n\n# Comprehensive workflow test\npython3 test_workflow.py\n```\n\n## API Overview\n\n**Core Endpoints:**\n- `POST /api/projects/` - Create magnetic field analysis project\n- `POST /api/datasets/upload/` - Upload CSV magnetometer data\n- `GET /api/datasets/{id}/data/` - Retrieve processed data with decimation\n- `POST /api/annotations/` - Create labeled data regions\n- `POST /api/training/start/` - Begin ML model training\n- `GET /api/training/status/{session_id}/` - Monitor training progress\n\n**Full API Documentation:** [docs/source/api_reference.rst](docs/source/api_reference.rst)\n\n## Known Issues\n\n### üêõ Current Bugs\n- **Training sessions** may hang with very large datasets (>20k points)\n- **Browser performance** degrades with >50 annotations on single chart\n- **CSV parsing** fails silently with some timestamp formats\n- **Memory leaks** in long-running training sessions\n\n### ‚ö†Ô∏è Reliability Issues\n- **No graceful failure** handling for interrupted operations\n- **Database locks** occur with rapid successive API calls\n- **File upload** corrupts with network interruptions\n- **Training progress** not recoverable after server restart\n\n## Development Roadmap\n\n### Phase 1: Production Readiness (High Priority)\n- [ ] **Authentication system** - User registration, login, permissions\n- [ ] **Production database** - PostgreSQL migration and optimization  \n- [ ] **Security hardening** - Input validation, rate limiting, HTTPS\n- [ ] **Error handling** - Graceful failures and recovery mechanisms\n- [ ] **Unit testing** - Comprehensive test suite beyond integration tests\n\n### Phase 2: Scalability (Medium Priority)\n- [ ] **Background processing** - Celery task queue for ML training\n- [ ] **File chunking** - Large dataset upload support (>100MB)\n- [ ] **Data validation** - Robust CSV format checking and sanitization\n- [ ] **Performance optimization** - Database query optimization, caching\n\n### Phase 3: Advanced Features (Low Priority)\n- [ ] **Model export/import** - Save/load trained models\n- [ ] **Batch processing** - Multiple dataset analysis\n- [ ] **Advanced ML algorithms** - Deep learning options\n- [ ] **Real-time data streaming** - Live magnetometer data processing\n\n## Documentation\n\n**Complete Documentation:** [GitHub Pages](https://manasp21.github.io/MagTrace/docs/index.html)\n\n**Key Resources:**\n- [Installation Guide](docs/source/installation.rst) - Setup and troubleshooting\n- [Quick Start Tutorial](docs/source/quick_start_tutorial.rst) - 10-minute walkthrough\n- [API Reference](docs/source/api_reference.rst) - Complete endpoint documentation\n- [Troubleshooting Guide](docs/source/troubleshooting.rst) - Common issues and solutions\n- [Testing Results](docs/source/testing_results.rst) - Validation and performance data\n\n## Contributing\n\n**Development Environment:**\n```bash\n# Fork repository, then:\ngit clone https://github.com/YOUR_USERNAME/MagTrace.git\ncd MagTrace/backend\nsource venv/bin/activate\npip install -r requirements-lite.txt\n\n# Run tests\npython3 test_workflow.py\npython manage.py test\n```\n\n**Code Standards:**\n- Follow Django best practices for backend development\n- Use vanilla JavaScript (no framework dependencies) for frontend\n- Include docstrings for all new functions and classes\n- Add integration tests for new API endpoints\n\n## License & Attribution\n\n**Author:** Manas Pandey  \n**Development Assistance:** Claude AI (Anthropic)  \n**License:** [Specify license]\n\n---\n\n## ‚ö†Ô∏è Important Notice\n\n**This software is in active development and not ready for production use without significant additional work.**\n\n**For Production Deployment:**\n1. Complete comprehensive testing with your specific datasets\n2. Implement authentication and security hardening\n3. Migrate to production-grade database and infrastructure\n4. Add monitoring, logging, and backup systems\n5. Conduct security audit and penetration testing\n\n**Use in controlled environments only until production readiness checklist is completed.**",
    "cached_at": 1750965290.0393775
  },
  "https://github.com/manasp21/magnav.py": {
    "name": "magnav.py",
    "full_name": "manasp21/magnav.py",
    "description": "MagNavPy is a Python library for magnetic navigation research and development. A port of magnav.jl.",
    "readme_description": "MagNavPy is a Python library for magnetic navigation research and development. It is a port of the original MagNav.jl (Julia) package, providing tools for simulating magnetic navigation scenarios, ...",
    "language": "Python",
    "stars": 1,
    "forks": 0,
    "watchers": 1,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-05-27T08:29:59Z",
    "updated_at": "2025-06-24T13:29:27Z",
    "pushed_at": "2025-06-13T07:59:17Z",
    "size": 19147,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/magnav.py",
    "clone_url": "https://github.com/manasp21/magnav.py.git",
    "ssh_url": "git@github.com:manasp21/magnav.py.git",
    "readme_content": "# MagNavPy\n\n[![PyPI version](https://img.shields.io/pypi/v/magnavpy.svg)](https://pypi.org/project/magnavpy/) <!-- Placeholder -->\n[![Build Status](https://img.shields.io/travis/com/yourusername/magnavpy.svg)](https://travis-ci.com/yourusername/magnavpy) <!-- Placeholder -->\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nMagNavPy is a Python library for magnetic navigation research and development. It is a port of the original [MagNav.jl](https://github.com/MIT-AI-Accelerator/MagNav.jl) (Julia) package, providing tools for simulating magnetic navigation scenarios, processing magnetometer data, compensating for aircraft magnetic noise, and implementing navigation filters.\n\n## Key Features\n\n*   **Data Handling**: Load, process, and manage flight path, INS, and magnetometer data, including built-in datasets.\n*   **Magnetic Anomaly Maps**: Utilities for loading, manipulating (e.g., upward continuation), and interpolating magnetic anomaly maps, with access to built-in global and regional maps.\n*   **Aeromagnetic Compensation**: Implementations of classical methods like Tolles-Lawson and advanced Neural Network-based models for compensating aircraft magnetic noise.\n*   **Navigation Algorithms**: Tools for magnetic navigation filtering, including Extended Kalman Filters (EKF) and the MagNav filter model, along with performance analysis using the Cram√©r‚ÄìRao Lower Bound (CRLB).\n*   **Simulation & Analysis**: Simulate magnetic navigation scenarios and analyze performance.\n*   **Data Visualization**: Plotting functions to visualize flight data, magnetic maps, and filter outputs.\n\n## Core Concepts\n\nMagNavPy utilizes several key data structures to organize and manage data:\n\n*   [`Map`](magnavpy/common_types.py:9): Represents a magnetic anomaly map.\n*   [`Traj`](magnavpy/magnav.py:40): Stores flight trajectory data.\n*   [`INS`](magnavpy/magnav.py:43): Holds Inertial Navigation System data.\n*   [`XYZ`](magnavpy/magnav.py:48): A general structure for flight data including position, time, and magnetic field measurements.\n*   [`EKF_RT`](magnavpy/ekf.py:81): Represents the state of a Real-Time Extended Kalman Filter.\n*   [`CompParams`](magnavpy/compensation.py:87), [`LinCompParams`](magnavpy/compensation.py:90), [`NNCompParams`](magnavpy/compensation.py:93): Structures for holding parameters for different compensation models.\n\n## Original Project\n\nThis project is a Python conversion of the [MagNav.jl](https://github.com/MIT-AI-Accelerator/MagNav.jl) library, originally developed by the MIT AI Accelerator. We acknowledge and thank the original authors for their foundational work.\n\n## Installation\n\n### Prerequisites\n\n*   Python 3.9 or higher.\n*   **GDAL**: This library depends on GDAL.\n    *   **For Windows users:** It is strongly recommended to install GDAL using pre-compiled wheels from sources like Christoph Gohlke's Unofficial Windows Binaries for Python Extension Packages. Ensure you download the wheel compatible with your Python version (e.g., Python 3.13) and system architecture (e.g., `win_amd64`). Direct installation via `pip install gdal` can often lead to compilation issues on Windows. After downloading the appropriate `.whl` file, you can install it using pip (e.g., `pip install GDAL-3.9.0-cp313-cp313-win_amd64.whl`).\n    *   **For other operating systems:** Please refer to the [official GDAL installation guide](https://gdal.org/download.html#binaries) for instructions.\n\n### Project Dependencies\n\nBeyond the prerequisites, MagNavPy relies on several Python packages for its functionality. All required packages are listed in the [`requirements.txt`](requirements.txt:0) file and can be installed as described in the installation steps. Key dependencies include:\n\n*   **gdal**: For geospatial data operations (Python bindings, requires system-level GDAL).\n*   **pandas**: For data manipulation and analysis.\n*   **torch**: For deep learning models and tensor computations.\n*   **matplotlib**: For plotting and visualization.\n*   **h5py**: For interacting with HDF5 files.\n*   **scipy**: For scientific and technical computing.\n*   **jax**: For high-performance numerical computing and machine learning research.\n*   **toml**: For parsing TOML configuration files.\n*   **scikit-learn**: For machine learning tools.\n*   **statsmodels**: For statistical modeling.\n*   **pytest**: For running the test suite.\n\nPlease ensure GDAL is installed on your system *before* running `pip install -r requirements.txt`.\n\n### Steps\n\n1.  **Clone the repository (if you haven't already):**\n    ```bash\n    git clone https://github.com/yourusername/MagNavPy.git # Replace with actual URL\n    ```\n    Navigate into the cloned repository's root directory (where `requirements.txt` is located). All subsequent installation commands should be run from this directory.\n\n2.  **Create and activate a Python virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    # On Windows\n    # venv\\Scripts\\activate\n    # On macOS/Linux\n    source venv/bin/activate\n    ```\n\n3.  **Install dependencies:**\n    Ensure your virtual environment is active and you are in the repository root directory. To install the required Python packages, run:\n    ```bash\n    pip install -r requirements.txt\n    ```\n    If you are developing the library, you might want to install it in editable mode:\n    ```bash\n    pip install -e .\n    ```\n\n## Data and Artifact Management\n\nMagNavPy requires specific data artifacts, such as magnetic anomaly maps and flight datasets, to function correctly. Currently, these artifacts are not managed or downloaded automatically by this Python port.\n\n**Manual Placement:**\nUsers are required to manually obtain these artifacts and place them in a directory named `artifacts_data`. This directory should be located at the **root of the `MagNavPy` repository** (e.g., if you cloned the repository into a folder named `MagNavPy`, the path would be `MagNavPy/artifacts_data/`).\n\n**Obtaining Artifacts:**\nInformation regarding the required artifacts and their original sources can be found in the [`Artifacts.toml`](../MagNav.jl/Artifacts.toml:1) file of the original [MagNav.jl project](https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/main/Artifacts.toml). Please refer to this file to identify and download the necessary data.\n\n## Usage\n\nMagNavPy provides functions for various stages of magnetic navigation processing. Here are examples of key functions:\n\n**Data Loading:**\nUse functions like [`create_xyz0`](magnavpy/create_xyz.py:9), [`get_xyz20`](magnavpy/create_xyz.py:11), or [`get_XYZ`](magnavpy/create_xyz.py:13) to load flight data. Built-in datasets like `sgl_2020_train` and `sgl_2021_train` are also available.\n\n**Map Handling:**\nLoad magnetic anomaly maps using [`get_map`](magnavpy/map_utils.py:9). Functions like [`upward_fft`](magnavpy/map_utils.py:25) are available for map manipulation.\n\n**Aeromagnetic Compensation:**\nTrain and test compensation models using [`comp_train`](magnavpy/compensation.py:16) and [`comp_test`](magnavpy/compensation.py:21). The library supports classical Tolles-Lawson and various Neural Network-based models (e.g., `:m1`, `:m2a`, `:m2b`, `:m2c`, `:m2d`, `:m3s`, `:m3v`).\n\n**Navigation Filtering:**\nRun navigation filters, such as the Extended Kalman Filter, using the [`run_filt`](magnavpy/magnav.py:33) function.\n\nFor more detailed examples, please refer to the `examples/` directory (if available) or the test scripts in the `tests/` directory.\n\n## Documentation\n\nFull documentation, including API references and usage guides, is generated using Sphinx.\n\nTo build the documentation locally:\n```bash\ncd docs\nmake html\n```\nThen, open `docs/build/html/index.html` in your web browser.\n\nThe documentation may also be hosted online in the future.\n\n## Testing\n\nTo run the test suite, navigate to the root directory of the project and use `pytest`:\n```bash\npytest tests/\n```\nThis will execute all tests defined in the `tests/` directory.\n\n## Current Status and Known Issues\n\nThis Python port of MagNav.jl is an ongoing development effort. While significant progress has been made, users should be aware of the following:\n\n*   **Ongoing Porting:** The library is actively being ported from Julia. Not all features and functionalities of the original MagNav.jl may be fully implemented or tested.\n*   **Environment and Imports:** Initial challenges with setting up the Python environment, particularly GDAL installation and resolving relative import paths within the `magnavpy` package, have been largely addressed.\n*   **Testing Coverage:** The original task mentioned \"pytest errors and otherwise.\" A comprehensive review and execution of the `pytest` test suite to ensure full functionality and identify remaining issues is still pending.\n*   **Manual Data Artifacts:** As detailed in the \"Data and Artifact Management\" section, data artifacts are currently handled manually. There is no automated download or management system within this Python port.\n*   **Documentation:** Documentation is being actively developed. While Sphinx documentation is available, it may not yet cover all aspects of the Python port comprehensively.\n\n## Contributing\n\nContributions are welcome! If you'd like to contribute, please feel free to open an issue to discuss your ideas or submit a pull request.\n(More detailed contribution guidelines may be added to a `CONTRIBUTING.md` file in the future.)\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details (assuming a `LICENSE` file will be added, or state \"MIT License\" directly). The original MagNav.jl project is also licensed under the MIT License.\n\n## Acknowledgements\n\n*   The developers and contributors of the original [MagNav.jl](https://github.com/MIT-AI-Accelerator/MagNav.jl).\n*   The broader open-source community for the tools and libraries that make this project possible.",
    "cached_at": 1750965293.6634803
  },
  "https://github.com/manasp21/PsiAnimator-MCP": {
    "name": "PsiAnimator-MCP",
    "full_name": "manasp21/PsiAnimator-MCP",
    "description": "A MCP-Server for Quantum Physics Simulation and Animation",
    "readme_description": "Quantum Physics Simulation and Animation Server A Model Context Protocol (MCP) server that integrates QuTip (Quantum Toolbox in Python) for quantum physics computations with Manim (Mathematical Ani...",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": "MIT License",
    "created_at": "2025-06-24T10:40:51Z",
    "updated_at": "2025-06-25T19:25:42Z",
    "pushed_at": "2025-06-25T19:25:39Z",
    "size": 217,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/PsiAnimator-MCP",
    "clone_url": "https://github.com/manasp21/PsiAnimator-MCP.git",
    "ssh_url": "git@github.com:manasp21/PsiAnimator-MCP.git",
    "readme_content": "# PsiAnimator-MCP\n\n**Quantum Physics Simulation and Animation Server**\n\nA Model Context Protocol (MCP) server that integrates [QuTip](https://qutip.org/) (Quantum Toolbox in Python) for quantum physics computations with [Manim](https://www.manim.community/) (Mathematical Animation Engine) for visualization.\n\n## Features\n\n- üî¨ **Quantum Physics Engine**: Complete state management, time evolution, and measurement tools\n- üé¨ **Manim Animations**: Publication-quality visualizations with quantum-specific scenes\n- üîå **MCP Integration**: Seamless integration with MCP-compatible clients\n- üßÆ **Scientific Computing**: Built on NumPy, SciPy, and QuTip for accuracy\n- üìä **Visualization Types**: Bloch spheres, Wigner functions, state tomography, circuits\n- üéì **Educational Focus**: Perfect for quantum mechanics education and research\n\n## Installation\n\n### Quick Install\n\n#### Option 1: One-line install (Unix/macOS)\n```bash\ncurl -fsSL https://raw.githubusercontent.com/username/PsiAnimator-MCP/main/scripts/install.sh | bash\n```\n\n#### Option 2: PowerShell (Windows)\n```powershell\niwr https://raw.githubusercontent.com/username/PsiAnimator-MCP/main/scripts/install.ps1 | iex\n```\n\n#### Option 3: pip (when available on PyPI)\n```bash\n# Core installation (quantum computation only)\npip install psianimator-mcp\n\n# Full installation with animation support\npip install \"psianimator-mcp[animation]\"\n\n# Development installation\npip install \"psianimator-mcp[dev,animation]\"\n```\n\n#### Option 4: From source\n```bash\ngit clone https://github.com/username/PsiAnimator-MCP.git\ncd PsiAnimator-MCP\n./scripts/install.sh --from-source\n```\n\n### Prerequisites\n\n- Python ‚â• 3.10\n- Git (for development installation)\n\n**For animation features:**\n- LaTeX (for advanced mathematical rendering)\n- FFmpeg (for video generation)\n- Cairo graphics library (for high-quality rendering)\n\n### Installation Options Explained\n\n**üöÄ Core Installation** (Recommended for most users)\n```bash\npip install psianimator-mcp\n```\n- Includes all quantum computation features\n- MCP server functionality\n- QuTip, NumPy, SciPy for quantum physics\n- Works immediately without system dependencies\n\n**üé¨ Animation Installation** (For visualization)\n```bash\npip install \"psianimator-mcp[animation]\"\n```\n- Everything from core installation\n- Manim for generating animations\n- Requires system dependencies (LaTeX, FFmpeg)\n- Larger download and installation time\n\n**üîß Development Installation**\n```bash\ngit clone https://github.com/username/PsiAnimator-MCP.git\ncd PsiAnimator-MCP\npip install -e \".[dev,animation]\"\n```\n\n### Why Animation is Optional\n\nAnimation features (Manim) are kept optional because:\n\n- **Heavy Dependencies**: Manim requires LaTeX, FFmpeg, and Cairo which can be several GB\n- **Installation Complexity**: System dependencies can fail on different platforms\n- **Use Case Separation**: Many users only need quantum computation, not visualization\n- **CI/Testing Reliability**: Core features can be tested without system dependencies\n- **Disk Space**: Core installation is ~100MB vs ~2GB+ with full animation stack\n\n### Dependencies\n\n**Core dependencies** (automatically installed):\n- QuTip ‚â• 4.7.0 (quantum physics computations)\n- MCP ‚â• 1.0.0 (Model Context Protocol)\n- NumPy, SciPy, matplotlib (scientific computing)\n- Pydantic, aiohttp (async web framework)\n\n**Animation dependencies** (optional extras):\n- Manim ‚â• 0.18.0 (mathematical animations)\n- h5py ‚â• 3.9.0 (data storage)\n- pandas ‚â• 2.0.0 (data analysis)\n\n### Post-Installation Setup\n\nAfter installation, run the setup command:\n```bash\npsianimator-mcp setup\n```\n\nThis will:\n- Create configuration directory (`~/.config/psianimator-mcp/`)\n- Copy example configuration file\n- Test installation and show feature availability\n- Provide Claude Desktop integration instructions\n\n### Verifying Installation\n\nCheck your installation status:\n```bash\npython -c \"import psianimator_mcp; print(f'‚úÖ Core: OK, Animation: {psianimator_mcp.is_animation_available()}')\"\n```\n\nExpected outputs:\n- `‚úÖ Core: OK, Animation: True` - Full installation with animations\n- `‚úÖ Core: OK, Animation: False` - Core installation only\n\n### Troubleshooting\n\n**Import Errors**\n```bash\n# If you get \"No module named 'psianimator_mcp'\"\npip install psianimator-mcp\n\n# If you get animation-related errors\npip install \"psianimator-mcp[animation]\"\n```\n\n**Animation Dependencies**\n```bash\n# Ubuntu/Debian\nsudo apt-get install texlive-latex-base ffmpeg libcairo2-dev\n\n# macOS\nbrew install mactex ffmpeg cairo\n\n# Windows\n# Install MiKTeX, FFmpeg from official websites\n```\n\n## Claude Desktop Integration\n\n### Automatic Configuration\n\nGenerate Claude Desktop configuration:\n```bash\npsianimator-mcp claude-config\n```\n\n### Manual Configuration\n\nAdd to your Claude Desktop configuration file:\n\n**Windows:** `%USERPROFILE%\\AppData\\Roaming\\Claude\\claude_desktop_config.json`\n**macOS:** `~/Library/Application Support/Claude/claude_desktop_config.json`\n**Linux:** `~/.config/claude-desktop/claude_desktop_config.json`\n\n```json\n{\n  \"mcpServers\": {\n    \"psianimator-mcp\": {\n      \"command\": \"python3\",\n      \"args\": [\"-m\", \"psianimator_mcp.cli\", \"serve\"],\n      \"env\": {\n        \"PSIANIMATOR_CONFIG\": \"~/.config/psianimator-mcp/config.json\"\n      }\n    }\n  }\n}\n```\n\n**Note:** Restart Claude Desktop after configuration changes.\n\n## Quick Start\n\n### 1. Start the Server\n\n**Default (serves via MCP protocol):**\n```bash\npsianimator-mcp\n```\n\n**Stdio transport explicitly:**\n```bash\npsianimator-mcp serve --transport stdio\n```\n\n**WebSocket transport:**\n```bash\npsianimator-mcp serve --transport websocket --port 3000\n```\n\n### 2. Test Installation\n\n```bash\npsianimator-mcp test\n```\n\n### 3. Basic Usage Example\n\n```python\nimport asyncio\nfrom psianimator_mcp.tools.quantum_state_tools import create_quantum_state\nfrom psianimator_mcp.tools.measurement_tools import measure_observable\nfrom psianimator_mcp.server.config import MCPConfig\n\nasync def basic_example():\n    config = MCPConfig()\n    \n    # Create a qubit in |0‚ü© state\n    result = await create_quantum_state({\n        'state_type': 'pure',\n        'system_dims': [2],\n        'parameters': {'state_indices': [0]},\n        'basis': 'computational'\n    }, config)\n    \n    state_id = result['state_id']\n    \n    # Measure ‚ü®œÉz‚ü©\n    measurement = await measure_observable({\n        'state_id': state_id,\n        'observable': 'sigmaz',\n        'measurement_type': 'expectation'\n    }, config)\n    \n    print(f\"‚ü®œÉz‚ü© = {measurement['measurement_results']['expectation_value']}\")\n\nasyncio.run(basic_example())\n```\n\n## MCP Tools\n\n### 1. `create_quantum_state`\nCreate quantum states of various types:\n- **Pure states**: |œà‚ü© (ket vectors)\n- **Mixed states**: œÅ (density matrices)\n- **Coherent states**: |Œ±‚ü© (harmonic oscillator)\n- **Squeezed states**: reduced uncertainty\n- **Thermal states**: finite temperature\n- **Fock states**: definite photon number\n\n### 2. `evolve_quantum_system`\nTime evolution with multiple methods:\n- **Unitary**: Schr√∂dinger equation (closed systems)\n- **Master equation**: Lindblad form (open systems)\n- **Monte Carlo**: Quantum trajectories\n- **Stochastic**: Continuous measurement\n\n### 3. `measure_observable`\nQuantum measurements and analysis:\n- **Expectation values**: ‚ü®O‚ü©\n- **Variances**: Œî¬≤O\n- **Probability distributions**: P(outcome)\n- **Correlation functions**: ‚ü®A‚ü©‚ü®B‚ü©\n\n### 4. `animate_quantum_process`\nGenerate Manim animations:\n- **Bloch sphere evolution**: Qubit dynamics\n- **Wigner functions**: Phase space representation\n- **State tomography**: Density matrix visualization\n- **Circuit execution**: Gate sequence animation\n- **Energy levels**: Population dynamics\n\n### 5. `quantum_gate_sequence`\nApply quantum gates with visualization:\n- **Single-qubit gates**: Pauli, Hadamard, rotations\n- **Two-qubit gates**: CNOT, CZ, SWAP\n- **Parameterized gates**: RX, RY, RZ with custom angles\n- **Circuit visualization**: Step-by-step animation\n\n### 6. `calculate_entanglement`\nCompute entanglement measures:\n- **Von Neumann entropy**: S(œÅ) = -Tr(œÅ log œÅ)\n- **Concurrence**: Two-qubit entanglement measure\n- **Negativity**: Partial transpose criterion\n- **Mutual information**: I(A:B)\n\n## Configuration\n\nConfigure via environment variables or `MCPConfig`:\n\n```python\nfrom psianimator_mcp.server.config import MCPConfig\n\nconfig = MCPConfig(\n    quantum_precision=1e-12,\n    max_hilbert_dimension=1024,\n    animation_cache_size=100,\n    output_directory=\"./output\",\n    render_backend=\"cairo\"\n)\n```\n\n### Environment Variables\n\nConfigure PsiAnimator-MCP via environment variables:\n\n**Server Configuration:**\n- `PSIANIMATOR_CONFIG` - Path to configuration file\n- `PSIANIMATOR_TRANSPORT` - Transport protocol (stdio/websocket)\n- `PSIANIMATOR_HOST` - Host for WebSocket transport\n- `PSIANIMATOR_PORT` - Port for WebSocket transport\n\n**Quantum Settings:**\n- `PSIANIMATOR_QUANTUM_PRECISION` - Quantum computation precision\n- `PSIANIMATOR_MAX_HILBERT_DIM` - Maximum Hilbert space dimension\n- `PSIANIMATOR_OUTPUT_DIR` - Output directory for animations\n\nExample:\n```bash\nexport PSIANIMATOR_TRANSPORT=websocket\nexport PSIANIMATOR_PORT=3001\npsianimator-mcp\n```\n\n## CLI Commands\n\nPsiAnimator-MCP provides several CLI commands:\n\n```bash\npsianimator-mcp                    # Start server (default: stdio)\npsianimator-mcp serve              # Start server with options\npsianimator-mcp config             # Show current configuration\npsianimator-mcp setup              # Run post-installation setup\npsianimator-mcp test               # Test installation\npsianimator-mcp claude-config      # Generate Claude Desktop config\npsianimator-mcp examples           # Show usage examples\npsianimator-mcp version            # Show version\npsianimator-mcp --help             # Show help\n```\n\n### Command Examples\n\n**Start with custom config:**\n```bash\npsianimator-mcp serve --config /path/to/config.json\n```\n\n**WebSocket mode:**\n```bash\npsianimator-mcp serve --transport websocket --host 0.0.0.0 --port 8080\n```\n\n**Verbose logging:**\n```bash\npsianimator-mcp serve -vvv\n```\n\n## Examples\n\nComprehensive examples are provided in the `examples/` directory:\n\n- `basic_usage.py` - Core functionality walkthrough\n- Bell state creation and entanglement analysis\n- Harmonic oscillator coherent state evolution\n- Multi-qubit quantum circuits\n\nRun examples:\n```bash\npython examples/basic_usage.py\n```\n\n## Development\n\n### Setup Development Environment\n\n```bash\ngit clone https://github.com/username/PsiAnimator-MCP.git\ncd PsiAnimator-MCP\npip install -e \".[dev]\"\npre-commit install\n```\n\n### Run Tests\n\n```bash\npytest tests/\n```\n\n### Code Quality\n\n```bash\nblack src/ tests/\nisort src/ tests/\nmypy src/\n```\n\n## Architecture\n\n```\nPsiAnimator-MCP/\n‚îú‚îÄ‚îÄ src/psianimator_mcp/\n‚îÇ   ‚îú‚îÄ‚îÄ server/          # MCP server implementation\n‚îÇ   ‚îú‚îÄ‚îÄ quantum/         # Quantum physics engine\n‚îÇ   ‚îú‚îÄ‚îÄ animation/       # Manim visualization components\n‚îÇ   ‚îî‚îÄ‚îÄ tools/           # MCP tool implementations\n‚îú‚îÄ‚îÄ tests/               # Comprehensive test suite\n‚îú‚îÄ‚îÄ examples/            # Usage examples\n‚îî‚îÄ‚îÄ docs/               # Documentation\n```\n\n## Limitations\n\n- Animation rendering requires sufficient system resources\n- Large Hilbert spaces (>1024 dimensions) may impact performance\n- Some advanced quantum error correction features are not yet implemented\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n\n## Contributing\n\nWe welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for:\n- Development guidelines\n- Code standards\n- Testing requirements\n- Pull request process\n\n## Support\n\n- **Documentation**: See `docs/API_REFERENCE.md`\n- **Examples**: Check `examples/` directory\n- **Issues**: Report bugs via GitHub issues",
    "cached_at": 1750965296.9038332
  },
  "https://github.com/manasp21/Coheron": {
    "name": "Coheron",
    "full_name": "manasp21/Coheron",
    "description": "An Evolutionary AI System for Quantum Optics",
    "readme_description": "An evolutionary AI system for breakthrough quantum optics research discovery Inspired by AlphaEvolve, Coheron uses advanced language models to generate, evaluate, and evolve quantum optics research...",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": null,
    "license": "MIT License",
    "created_at": "2025-06-22T16:08:31Z",
    "updated_at": "2025-06-25T19:12:13Z",
    "pushed_at": "2025-06-25T19:12:09Z",
    "size": 592,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/Coheron",
    "clone_url": "https://github.com/manasp21/Coheron.git",
    "ssh_url": "git@github.com:manasp21/Coheron.git",
    "readme_content": "# Coheron\n\n**An evolutionary AI system for breakthrough quantum optics research discovery**\n\nInspired by AlphaEvolve, Coheron uses advanced language models to generate, evaluate, and evolve quantum optics research solutions through physics-aware evaluation and evolutionary algorithms. The system automatically discovers novel research approaches by evolving populations of solutions across generations.\n\n[![Python 3.9+](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/downloads/)\n[![A4F API](https://img.shields.io/badge/A4F-Compatible-green.svg)](https://www.a4f.co/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n## üåü Features\n\n- **üß¨ Evolutionary Research Discovery**: AlphaEvolve-inspired architecture for systematic research evolution\n- **üî¨ Physics-Aware Evaluation**: Rigorous evaluation against analytical benchmarks and experimental feasibility\n- **üîÑ Flexible Model Switching**: Easy switching between Gemini, Claude, GPT-4, and other models via A4F\n- **üìä Comprehensive Analytics**: Track research evolution, breakthrough discoveries, and model performance\n- **üéØ Specialized Categories**: Focus on cavity QED, squeezed light, photon blockade, quantum metrology, and optomechanics\n- **üíæ Research Database**: SQLite-based storage for evolution tracking and lineage analysis\n- **üñ•Ô∏è Windows Compatible**: Unicode-safe logging and console output for all platforms\n\n## üöÄ Quick Start\n\n### Prerequisites\n\n- Python 3.9 or higher\n- A4F API key ([Get one here](https://www.a4f.co/))\n\n### Installation\n\n1. **Clone the repository**\n   ```bash\n   git clone <repository-url>\n   cd Coheron\n   ```\n\n2. **Install dependencies**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n3. **Set up environment**\n   ```bash\n   # Set your A4F API key\n   export A4F_API_KEY=\"ddc-a4f-your-api-key-here\"\n   \n   # Or on Windows:\n   set A4F_API_KEY=ddc-a4f-your-api-key-here\n   ```\n\n4. **Run your first evolution**\n   ```bash\n   python src/main.py evolve --generations 10\n   ```\n\n## üìñ Usage Guide\n\n### Basic Commands\n\n```bash\n# Run research evolution (default: Gemini 2.5 Flash)\npython src/main.py evolve --generations 20\n\n# Switch to a different model  \npython src/main.py evolve --model \"anthropic/claude-3.5-sonnet\" --generations 15\n\n# Focus on specific research category\npython src/main.py evolve --category cavity_qed --generations 25\n\n# Evaluate research content\npython src/main.py evaluate --content \"Design a cavity QED system...\" --category cavity_qed\n\n# Analyze results and generate plots\npython src/main.py analyze --database --plots\n\n# Test system components\npython src/main.py test --full\n\n# Benchmark different models\npython src/main.py benchmark --compare-models\n```\n\n### Evolution Parameters Explained\n\n**Generations**: Number of evolutionary cycles. Each generation:\n- Evaluates current population solutions\n- Selects elite solutions for survival\n- Creates new solutions through mutation and crossover\n- Introduces novel exploratory solutions\n\n**Population**: Number of research solutions maintained per generation. Larger populations explore more diverse approaches but require more computational resources.\n\n### Advanced Usage Examples\n\n#### Custom Evolution Parameters\n```bash\npython src/main.py evolve \\\n  --generations 50 \\\n  --population 15 \\\n  --model \"anthropic/claude-3.5-sonnet\" \\\n  --output-dir custom_results \\\n  --save-interval 3\n```\n\n#### Demo Mode (No API Key Required)\n```bash\n# Test the system without API calls\npython src/main.py evolve --demo --generations 5 --population 3\n```\n\n#### Detailed Research Evaluation\n```bash\npython src/main.py evaluate \\\n  --content research_paper.txt \\\n  --category quantum_metrology \\\n  --detailed \\\n  --save-result evaluation_results.json\n```\n\n#### Database Analysis\n```bash\npython src/main.py analyze \\\n  --database \\\n  --category squeezed_light \\\n  --plots \\\n  --export analysis_export.json\n```\n\n## üé® Custom Prompts and Configuration\n\n### Custom Research Prompts\n\nEdit `config/prompts.yaml` to customize research generation:\n\n```yaml\n# Add your custom quantum optics research prompts\ncustom_research_prompts:\n  cavity_qed:\n    base_prompt: |\n      Design a novel cavity QED system that achieves strong coupling between {atom_type} and {cavity_mode}.\n      Consider {coupling_mechanism} and optimize for {target_metric}.\n      \n      Requirements:\n      - Coupling strength: g > {min_coupling} Hz\n      - Quality factor: Q > {min_quality}\n      - Operating temperature: {temperature}\n      \n      Provide detailed analysis including:\n      1. System architecture and parameters\n      2. Theoretical predictions\n      3. Experimental feasibility\n      4. Performance benchmarks\n\n    mutation_prompts:\n      - \"Modify the cavity geometry to enhance {parameter}\"\n      - \"Explore alternative {component} designs\"\n      - \"Optimize for {new_metric} instead of {old_metric}\"\n      \n    crossover_prompt: |\n      Combine the following two cavity QED approaches:\n      \n      Approach 1: {approach_1}\n      Approach 2: {approach_2}\n      \n      Create a hybrid system that leverages the strengths of both approaches.\n\n# Custom evaluation criteria\ncustom_evaluation:\n  cavity_qed:\n    physics_checks:\n      - \"Verify coupling strength calculation: g = ...\"\n      - \"Check cooperativity C = 4g¬≤/(Œ∫Œ≥)\"\n      - \"Validate quality factor estimates\"\n    \n    benchmarks:\n      - name: \"Strong coupling threshold\"\n        condition: \"g > sqrt(Œ∫Œ≥/4)\"\n        points: 10\n      \n      - name: \"Room temperature operation\"\n        condition: \"kT < ƒßœâ\"\n        points: 15\n```\n\n### Custom Research Categories\n\nAdd new categories by extending the configuration:\n\n```yaml\n# In config/config.yaml\nresearch_categories:\n  # Existing categories...\n  \n  quantum_sensing:\n    description: \"Quantum-enhanced sensing and metrology\"\n    focus_areas:\n      - \"Atomic interferometry\"\n      - \"Spin squeezing\"\n      - \"Quantum Fisher information\"\n    \n    prompts:\n      base: \"Design a quantum sensing protocol that...\"\n      mutations: [\"Enhance sensitivity by...\", \"Reduce decoherence through...\"]\n    \n    evaluation_weights:\n      sensitivity: 0.4\n      robustness: 0.3\n      practicality: 0.3\n```\n\n### Model Configuration\n\nConfigure different models in `config/config.yaml`:\n\n```yaml\napi:\n  provider: \"a4f\"\n  api_key: \"${A4F_API_KEY}\"\n  base_url: \"https://api.a4f.co/v1\"\n\n# Current model (change this to switch models)\ncurrent_model: \"provider-5/gemini-2.5-flash-preview-04-17\"\n\n# Available models\nmodels:\n  \"provider-5/gemini-2.5-flash-preview-04-17\":\n    name: \"Gemini 2.5 Flash\"\n    max_tokens: 8192\n    temperature: 0.7\n    cost_per_1k_tokens: 0.0005\n    strengths: [\"Fast\", \"Cost-effective\", \"Good reasoning\"]\n    \n  \"anthropic/claude-3.5-sonnet\":\n    name: \"Claude 3.5 Sonnet\"\n    max_tokens: 4096\n    temperature: 0.7\n    cost_per_1k_tokens: 0.003\n    strengths: [\"Physics expertise\", \"Analytical\", \"Detailed explanations\"]\n    \n  \"openai/gpt-4-turbo\":\n    name: \"GPT-4 Turbo\"\n    max_tokens: 4096\n    temperature: 0.7\n    cost_per_1k_tokens: 0.01\n    strengths: [\"Structured output\", \"Mathematical precision\", \"Code generation\"]\n```\n\n### Custom Evaluation Criteria\n\nExtend `config/evaluation_criteria.yaml`:\n\n```yaml\n# Custom scoring rubrics\ncustom_scoring:\n  feasibility:\n    energy_conservation:\n      weight: 0.3\n      check: \"Verify energy balance in all processes\"\n      scoring:\n        perfect: \"All energy terms accounted for\"\n        good: \"Minor approximations justified\"\n        poor: \"Energy conservation violated\"\n    \n    material_properties:\n      weight: 0.4\n      check: \"Realistic material parameters\"\n      benchmarks:\n        - \"Refractive index within known range\"\n        - \"Loss rates experimentally achievable\"\n        - \"Temperature requirements realistic\"\n  \n  novelty:\n    parameter_space:\n      weight: 0.5\n      check: \"Explores new parameter regimes\"\n      criteria:\n        - \"Previously unexplored coupling strengths\"\n        - \"Novel material combinations\"\n        - \"Innovative system architectures\"\n\n# Custom physics benchmarks\nphysics_benchmarks:\n  cavity_qed:\n    analytical_solutions:\n      jaynes_cummings:\n        description: \"Two-level atom in cavity\"\n        parameters: [\"g\", \"œâ_a\", \"œâ_c\", \"Œ∫\", \"Œ≥\"]\n        solutions:\n          vacuum_rabi: \"Œ©_R = 2g\"\n          cooperativity: \"C = 4g¬≤/(Œ∫Œ≥)\"\n          critical_coupling: \"g_c = ‚àö(Œ∫Œ≥)/2\"\n        \n      dressed_states:\n        description: \"Strong coupling eigenstates\"\n        formulas:\n          splitting: \"2g‚àö(n+1)\"\n          frequencies: \"œâ_¬± = (œâ_a + œâ_c)/2 ¬± g‚àö(n+1)\"\n```\n\n### Seed Research Customization\n\nProvide high-quality starting examples in `data/seed_research.json`:\n\n```json\n{\n  \"cavity_qed\": [\n    {\n      \"title\": \"Ultra-strong coupling in circuit QED\",\n      \"content\": \"Design of superconducting circuit achieving g/œâ = 0.2...\",\n      \"category\": \"cavity_qed\",\n      \"parameters\": {\n        \"coupling_strength\": 1e9,\n        \"quality_factor\": 1e6,\n        \"cooperativity\": 1000\n      },\n      \"evaluation_scores\": {\n        \"feasibility\": 0.9,\n        \"mathematics\": 0.95,\n        \"novelty\": 0.8,\n        \"performance\": 0.85\n      }\n    }\n  ],\n  \n  \"custom_category\": [\n    {\n      \"title\": \"Your custom research example\",\n      \"content\": \"Detailed description of your approach...\",\n      \"category\": \"custom_category\",\n      \"parameters\": {...},\n      \"evaluation_scores\": {...}\n    }\n  ]\n}\n```\n\n## üèóÔ∏è System Architecture\n\n### Core Components\n\n```\nCoheron/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ main.py                 # CLI interface and application entry\n‚îÇ   ‚îú‚îÄ‚îÄ evolution_controller.py # Main evolution loop (AlphaEvolve-inspired)\n‚îÇ   ‚îú‚îÄ‚îÄ llm_interface.py        # A4F API integration with model switching\n‚îÇ   ‚îú‚îÄ‚îÄ research_generator.py   # Quantum research prompt generation\n‚îÇ   ‚îú‚îÄ‚îÄ evaluator.py            # Physics-aware evaluation system\n‚îÇ   ‚îú‚îÄ‚îÄ database.py             # Research storage and tracking\n‚îÇ   ‚îî‚îÄ‚îÄ utils.py                # Utility functions and helpers\n‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îú‚îÄ‚îÄ config.yaml             # Model and system configuration\n‚îÇ   ‚îú‚îÄ‚îÄ prompts.yaml            # Research prompt templates\n‚îÇ   ‚îî‚îÄ‚îÄ evaluation_criteria.yaml # Scoring rubrics and benchmarks\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îú‚îÄ‚îÄ seed_research.json      # Initial high-quality examples\n‚îÇ   ‚îú‚îÄ‚îÄ benchmarks.json         # Analytical solution benchmarks\n‚îÇ   ‚îî‚îÄ‚îÄ research_history.db     # Evolution tracking database\n‚îî‚îÄ‚îÄ results/                    # Generated results and analysis\n```\n\n### Evolution Process Flow\n\n1. **Initialization Phase**\n   - Load seed research examples from `data/seed_research.json`\n   - Generate initial population using research prompts\n   - Establish baseline evaluation scores\n\n2. **Generation Loop** (Repeated for specified generations)\n   - **Selection**: Choose elite solutions based on evaluation scores\n   - **Mutation**: Create variations of successful solutions\n   - **Crossover**: Combine features from multiple parent solutions\n   - **Exploration**: Generate novel solutions for diversity\n   - **Evaluation**: Score all candidates using physics-aware criteria\n   - **Survival**: Select best solutions for next generation\n\n3. **Analysis and Export**\n   - Track evolution progress and identify breakthroughs\n   - Generate visualization plots and comprehensive reports\n   - Store results in database for future analysis\n\n## üéØ Research Categories Deep Dive\n\n### Cavity QED\n**Focus**: Single atom-photon interactions in optical cavities\n\nKey Research Areas:\n- **Strong Coupling**: g > ‚àö(Œ∫Œ≥) regimes where atom-photon interaction dominates\n- **Collective Effects**: Superradiance and subradiance in multi-atom systems  \n- **Quantum Memory**: Storing and retrieving photonic quantum states\n- **Deterministic Gates**: Single-photon controlled phase gates\n\nExample Prompts:\n```yaml\ncavity_qed_prompts:\n  - \"Design a cavity QED system achieving g/Œ∫ > 100 with single atoms\"\n  - \"Propose a quantum memory protocol with >95% fidelity\"\n  - \"Optimize cavity geometry for enhanced atom-photon coupling\"\n```\n\n### Squeezed Light\n**Focus**: Quantum noise reduction below the standard quantum limit\n\nKey Research Areas:\n- **Parametric Oscillators**: OPO and OPA based squeezing generation\n- **Spin Squeezing**: Collective atomic state squeezing for enhanced sensitivity\n- **Multimode Entanglement**: Einstein-Podolsky-Rosen correlations\n- **Quantum Sensing**: Gravitational wave detection and atomic clocks\n\nExample Benchmarks:\n```yaml\nsqueezed_light_benchmarks:\n  squeezing_parameter: \n    excellent: \"> 10 dB\"\n    good: \"5-10 dB\"\n    poor: \"< 5 dB\"\n  \n  detection_efficiency:\n    threshold: \"> 90%\"\n    justification: \"Losses rapidly degrade squeezing\"\n```\n\n### Photon Blockade\n**Focus**: Single-photon nonlinear optics and deterministic photon sources\n\nKey Research Areas:\n- **Conventional Blockade**: Strong Kerr nonlinearity (U >> Œ∫)\n- **Unconventional Blockade**: Interference-based mechanisms\n- **Single Photon Sources**: On-demand photon generation\n- **Photonic Quantum Gates**: Two-photon controlled operations\n\n### Quantum Metrology  \n**Focus**: Quantum-enhanced sensing beyond classical limits\n\nKey Research Areas:\n- **N00N States**: Quantum superposition for phase sensing\n- **Atomic Clocks**: Optical lattice and ion trap frequency standards\n- **Quantum Fisher Information**: Fundamental sensitivity bounds\n- **Heisenberg Scaling**: 1/N sensitivity enhancement\n\n### Optomechanics\n**Focus**: Quantum coupling between light and mechanical motion\n\nKey Research Areas:\n- **Ground State Cooling**: Laser cooling of mechanical oscillators\n- **Quantum State Transfer**: Optical-to-mechanical quantum state mapping\n- **Hybrid Systems**: Coupling to spins, atoms, and superconducting circuits\n- **Quantum Transduction**: Microwave-to-optical frequency conversion\n\n## üìä Physics-Aware Evaluation System\n\nThe evaluation system provides rigorous scoring across four key dimensions:\n\n### 1. Feasibility (25%) - Physical Realizability\n- **Energy Conservation**: Verify all energy transfers and conservation laws\n- **Fundamental Limits**: Check against quantum limits (uncertainty principle, no-cloning)\n- **Material Properties**: Realistic parameters for existing or proposed materials\n- **Experimental Complexity**: Assessment of required experimental capabilities\n\n**Example Checks**:\n```python\n# Energy conservation in parametric processes\ndef check_energy_conservation(pump_freq, signal_freq, idler_freq):\n    return abs(pump_freq - signal_freq - idler_freq) < tolerance\n\n# Uncertainty principle compliance  \ndef check_uncertainty_limit(delta_x, delta_p, hbar):\n    return delta_x * delta_p >= hbar / 2\n```\n\n### 2. Mathematics (30%) - Analytical Correctness\n- **Benchmark Verification**: Comparison with known analytical solutions\n- **Dimensional Analysis**: Units and scaling consistency\n- **Approximation Validity**: Justification of approximations used\n- **Derivation Logic**: Step-by-step mathematical reasoning\n\n**Benchmark Examples**:\n```yaml\njaynes_cummings_benchmarks:\n  vacuum_rabi_splitting: \"2g\"\n  dressed_state_energies: \"œâ‚ÇÄ ¬± g‚àö(n+1)\"\n  cooperativity: \"4g¬≤/(Œ∫Œ≥)\"\n\nharmonic_oscillator_benchmarks:\n  ground_state_energy: \"ƒßœâ/2\"\n  zero_point_fluctuations: \"‚àö(ƒß/(2mœâ))\"\n  quantum_correlation_function: \"‚ü®n‚ü© + 1\"\n```\n\n### 3. Novelty (25%) - Research Innovation\n- **Parameter Exploration**: Novel regimes or unexplored parameter spaces\n- **Architectural Innovation**: New system designs or configurations\n- **Application Breakthroughs**: Potential for significant impact\n- **Interdisciplinary Connections**: Links between different physics areas\n\n**Novelty Scoring**:\n```python\ndef evaluate_novelty(solution, database):\n    # Check parameter space coverage\n    param_novelty = assess_parameter_uniqueness(solution.parameters, database)\n    \n    # Evaluate architectural innovation\n    design_novelty = analyze_system_architecture(solution.design)\n    \n    # Assess breakthrough potential\n    impact_score = evaluate_impact_potential(solution.applications)\n    \n    return weighted_average([param_novelty, design_novelty, impact_score])\n```\n\n### 4. Performance (20%) - Quantitative Metrics\n- **Category-Specific Metrics**: Coupling strength, squeezing level, efficiency, etc.\n- **Experimental Records**: Comparison with state-of-the-art results\n- **Optimization Potential**: Theoretical limits and improvement pathways\n- **Scalability**: Extension to larger systems or higher performance\n\n**Performance Thresholds**:\n```yaml\nperformance_benchmarks:\n  cavity_qed:\n    strong_coupling: \"g > ‚àö(Œ∫Œ≥)\"\n    cooperativity: \"C > 1\"\n    single_atom_coupling: \"g > 10 MHz\"\n  \n  squeezed_light:\n    squeezing_level: \"> 10 dB\"\n    detection_efficiency: \"> 90%\"\n    bandwidth: \"> 1 MHz\"\n  \n  optomechanics:\n    cooling_efficiency: \"n_f < 1\"\n    coupling_rate: \"g > Œ∫_m\"\n    quality_factor: \"Q > 10‚Å∂\"\n```\n\n## üé® Visualization and Analysis Tools\n\n### Evolution Progress Tracking\n```bash\n# Generate comprehensive evolution plots\npython src/main.py analyze --database --plots --export detailed_analysis.json\n\n# View results interactively  \npython view_results.py results/\n```\n\nGenerated visualizations include:\n- **Score Evolution**: Best and average scores across generations\n- **Diversity Tracking**: Population diversity over time\n- **Category Performance**: Comparative analysis across research areas\n- **Breakthrough Timeline**: Discovery of high-impact solutions\n\n### Model Performance Comparison\n```bash\n# Benchmark multiple models on physics problems\npython src/main.py benchmark \\\n  --compare-models \\\n  --models \"provider-5/gemini-2.5-flash-preview-04-17\" \"anthropic/claude-3.5-sonnet\" \\\n  --physics-accuracy\n```\n\n### Custom Analysis Scripts\n```python\n# Example custom analysis\nfrom database import ResearchDatabase\nfrom utils import create_evolution_plot, export_results_report\n\ndb = ResearchDatabase()\nsolutions = db.get_solutions_by_category(\"cavity_qed\")\nanalysis = analyze_breakthrough_patterns(solutions)\ncreate_custom_visualization(analysis)\n```\n\n## üîß Advanced Configuration Options\n\n### Custom Model Integration\n```yaml\n# Add new models to config/config.yaml\nmodels:\n  \"custom/your-model\":\n    name: \"Your Custom Model\"\n    max_tokens: 4096\n    temperature: 0.7\n    cost_per_1k_tokens: 0.002\n    api_endpoint: \"custom_endpoint\"\n    headers:\n      Authorization: \"Bearer ${CUSTOM_API_KEY}\"\n    strengths: [\"Domain expertise\", \"Fast inference\"]\n```\n\n### Evolution Algorithm Tuning\n```yaml\nevolution:\n  population_size: 15              # Solutions per generation\n  max_generations: 50              # Total evolution cycles\n  mutation_rate: 0.3               # Fraction undergoing mutation\n  crossover_rate: 0.7              # Fraction created via crossover\n  elite_retention: 0.2             # Top solutions preserved\n  exploration_rate: 0.1            # Novel solutions per generation\n  diversity_pressure: 0.15         # Penalty for similar solutions\n  convergence_threshold: 0.001     # Stop if improvement < threshold\n```\n\n### Custom Physics Validation\n```python\n# Add to src/evaluator.py\ndef custom_physics_check(solution_content):\n    \"\"\"Implement domain-specific physics validation\"\"\"\n    \n    # Extract parameters\n    params = extract_physics_parameters(solution_content)\n    \n    # Custom validation rules\n    if 'coupling_strength' in params:\n        g = params['coupling_strength']\n        # Check realistic coupling strength\n        if g > 1e12:  # > 1 THz unrealistic\n            return False, \"Coupling strength too high\"\n    \n    # Quantum mechanics consistency\n    if violates_uncertainty_principle(params):\n        return False, \"Violates uncertainty principle\"\n    \n    return True, \"Physics checks passed\"\n```\n\n## üìà Model Comparison Guide\n\n### Current Model Performance on Quantum Physics\n\n| Model | Physics Accuracy | Mathematical Rigor | Novel Insights | Cost Efficiency | Best Use Cases |\n|-------|------------------|-------------------|----------------|-----------------|----------------|\n| **Gemini 2.5 Flash** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Rapid prototyping, exploration |\n| **Claude 3.5 Sonnet** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | Complex analysis, detailed derivations |\n| **GPT-4 Turbo** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | Structured outputs, systematic approaches |\n\n### Model Selection Guidelines\n\n**For Exploration & Testing**:\n- Use Gemini 2.5 Flash (free/low-cost)\n- Enable demo mode for offline testing\n- Focus on broad parameter sweeps\n\n**For Production Research**:\n- Use Claude 3.5 Sonnet for physics depth\n- Enable detailed evaluation and logging\n- Generate comprehensive reports\n\n**For Specific Tasks**:\n- **Mathematical Derivations**: Claude 3.5 Sonnet\n- **System Design**: GPT-4 Turbo  \n- **Parameter Optimization**: Gemini 2.5 Flash\n- **Novel Concepts**: Claude 3.5 Sonnet\n\n## üß™ Testing and Validation\n\n### System Testing\n```bash\n# Test all components\npython src/main.py test --full\n\n# Test specific components\npython src/main.py test --evaluator    # Physics evaluation system\npython src/main.py test --database     # Data storage and retrieval\npython src/main.py test --model \"provider-5/gemini-2.5-flash-preview-04-17\"\n\n# Test Unicode handling (Windows)\npython test_unicode_fix.py\n\n# Test demo mode (no API required)\npython test_demo.py\n```\n\n### Physics Accuracy Validation\n```bash\n# Test physics accuracy across categories\npython src/main.py benchmark --physics-accuracy\n\n# Compare model physics understanding\npython src/main.py benchmark --compare-models --physics-accuracy\n```\n\n### Custom Validation Scripts\n```python\n# Validate custom research content\ndef validate_research(content_file, category):\n    with open(content_file, 'r') as f:\n        content = f.read()\n    \n    evaluator = QuantumOpticsEvaluator()\n    result = evaluator.evaluate_research({\n        'content': content,\n        'category': category,\n        'title': 'Custom Research'\n    })\n    \n    return result\n```\n\n## üêõ Troubleshooting Guide\n\n### Common Issues and Solutions\n\n**API Connection Errors**\n```bash\n# Verify API key\necho $A4F_API_KEY\n\n# Test API connectivity\npython src/main.py test --model \"provider-5/gemini-2.5-flash-preview-04-17\"\n\n# Check API quota and usage\ncurl -H \"Authorization: Bearer $A4F_API_KEY\" https://api.a4f.co/v1/models\n```\n\n**Unicode/Encoding Errors (Windows)**\n```bash\n# Test Unicode fixes\npython test_unicode_fix.py\n\n# If issues persist, use demo mode\npython src/main.py evolve --demo --generations 5\n```\n\n**Memory Issues**\n```bash\n# Reduce computational load\npython src/main.py evolve --population 5 --generations 10\n\n# Use streaming for large datasets\npython src/main.py analyze --database --streaming\n```\n\n**Database Corruption**\n```bash\n# Reset database (warning: loses history)\nrm data/research_history.db\n\n# Backup before operations\ncp data/research_history.db data/backup_$(date +%Y%m%d).db\n```\n\n**Model Performance Issues**\n```bash\n# Check model availability\npython src/main.py benchmark --models \"provider-5/gemini-2.5-flash-preview-04-17\"\n\n# Switch to alternative model\npython src/main.py evolve --model \"anthropic/claude-3.5-sonnet\"\n\n# Enable detailed logging\npython src/main.py evolve --log-level DEBUG --log-file\n```\n\n### Performance Optimization\n\n**Speed Optimization**:\n- Use faster models (Gemini Flash) for exploration\n- Reduce population size and generations\n- Enable parallel processing in config\n- Use category focus to narrow search space\n\n**Quality Optimization**:\n- Use higher-capability models (Claude Sonnet)\n- Increase population size for diversity\n- Enable detailed evaluation scoring\n- Provide high-quality seed research\n\n**Cost Optimization**:\n- Use free models for testing\n- Implement request caching\n- Batch API calls efficiently\n- Monitor usage with detailed logging\n\n## üöÄ Advanced Use Cases\n\n### Multi-Domain Research\n```bash\n# Explore quantum sensing applications\npython src/main.py evolve --category quantum_metrology --generations 30\n\n# Cross-domain optimization (optomechanics + sensing)\npython custom_scripts/cross_domain_evolution.py\n```\n\n### Automated Literature Review\n```bash\n# Evaluate existing research papers\nfor paper in papers/*.txt; do\n    python src/main.py evaluate --content \"$paper\" --detailed --save-result \"evaluations/$(basename $paper .txt).json\"\ndone\n\n# Analyze evaluation results\npython analyze_literature.py evaluations/\n```\n\n### Custom Research Pipelines\n```python\n# research_pipeline.py\nfrom evolution_controller import QuantumResearchEvolver\nfrom evaluator import QuantumOpticsEvaluator\n\ndef run_custom_pipeline():\n    # Stage 1: Broad exploration\n    evolver = QuantumResearchEvolver()\n    evolver.population_size = 20\n    initial_solutions = evolver.evolve_research(15)\n    \n    # Stage 2: Focused optimization  \n    top_solutions = initial_solutions[:5]\n    evolver.seed_solutions = top_solutions\n    evolver.population_size = 10\n    final_solutions = evolver.evolve_research(25)\n    \n    # Stage 3: Detailed analysis\n    evaluator = QuantumOpticsEvaluator()\n    detailed_results = []\n    for solution in final_solutions[:3]:\n        result = evaluator.detailed_evaluation(solution)\n        detailed_results.append(result)\n    \n    return detailed_results\n```\n\n## üìö Complete Examples\n\n### Example 1: Cavity QED Breakthrough Discovery\n```bash\n# Set up for cavity QED research\nexport A4F_API_KEY=\"your-api-key\"\n\n# Run focused evolution\npython src/main.py evolve \\\n  --category cavity_qed \\\n  --model \"anthropic/claude-3.5-sonnet\" \\\n  --generations 25 \\\n  --population 12 \\\n  --output-dir cavity_qed_results\n\n# Analyze breakthroughs\npython src/main.py analyze \\\n  --database \\\n  --category cavity_qed \\\n  --plots \\\n  --export cavity_qed_analysis.json\n\n# View results\npython view_results.py cavity_qed_results/\n```\n\n### Example 2: Multi-Model Comparison Study\n```bash\n# Test different models on same problem\nmodels=(\"provider-5/gemini-2.5-flash-preview-04-17\" \"anthropic/claude-3.5-sonnet\" \"openai/gpt-4-turbo\")\n\nfor model in \"${models[@]}\"; do\n    echo \"Testing $model...\"\n    python src/main.py evolve \\\n      --model \"$model\" \\\n      --generations 15 \\\n      --population 8 \\\n      --output-dir \"comparison_$model\"\ndone\n\n# Compare results\npython compare_models.py comparison_*/\n```\n\n### Example 3: Custom Research Evaluation\n```bash\n# Prepare research content\ncat > my_research.txt << EOF\nWe propose a novel cavity QED system using diamond nitrogen-vacancy centers \ncoupled to a photonic crystal cavity. The system achieves strong coupling \nwith g = 50 MHz, cavity decay Œ∫ = 10 MHz, and NV transition linewidth Œ≥ = 15 MHz.\nThe cooperativity C = 4g¬≤/(Œ∫Œ≥) ‚âà 67 enables efficient quantum state transfer\nbetween NV spin states and cavity photons.\nEOF\n\n# Evaluate the research\npython src/main.py evaluate \\\n  --content my_research.txt \\\n  --category cavity_qed \\\n  --detailed \\\n  --save-result my_evaluation.json\n\n# View detailed results\ncat my_evaluation.json | python -m json.tool\n```\n\n### Example 4: Automated Research Pipeline\n```python\n#!/usr/bin/env python3\n\"\"\"\nAutomated research discovery pipeline\n\"\"\"\n\nimport sys\nimport json\nfrom pathlib import Path\n\n# Add src to path\nsys.path.insert(0, str(Path(__file__).parent / 'src'))\n\nfrom evolution_controller import QuantumResearchEvolver\nfrom database import ResearchDatabase\nfrom utils import export_results_report\n\ndef main():\n    \"\"\"Run automated research pipeline\"\"\"\n    \n    # Initialize systems\n    evolver = QuantumResearchEvolver()\n    db = ResearchDatabase()\n    \n    # Configuration\n    categories = ['cavity_qed', 'squeezed_light', 'optomechanics']\n    models = ['provider-5/gemini-2.5-flash-preview-04-17', 'anthropic/claude-3.5-sonnet']\n    \n    all_results = {}\n    \n    for category in categories:\n        print(f\"Exploring {category}...\")\n        category_results = {}\n        \n        for model in models:\n            print(f\"  Using model: {model}\")\n            \n            # Configure evolution\n            evolver.llm.switch_model(model)\n            evolver.population_size = 10\n            \n            # Run evolution\n            solutions = evolver.evolve_research(20)\n            \n            # Store results\n            category_results[model] = {\n                'best_score': solutions[0].evaluation_result.total_score,\n                'breakthrough_count': len([s for s in solutions if s.evaluation_result.total_score > 0.8]),\n                'solutions': [solution.__dict__ for solution in solutions[:5]]\n            }\n            \n            # Save to database\n            for solution in solutions[:10]:\n                db.store_solution(solution.__dict__)\n        \n        all_results[category] = category_results\n    \n    # Export comprehensive report\n    with open('automated_research_report.json', 'w') as f:\n        json.dump(all_results, f, indent=2)\n    \n    print(\"Automated research pipeline completed!\")\n    print(\"Results saved to automated_research_report.json\")\n\nif __name__ == '__main__':\n    main()\n```\n\n## üìÑ License and Contributing\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n### Contributing Guidelines\n1. **Fork the repository** and create your feature branch\n2. **Add tests** for new functionality\n3. **Follow physics validation** standards\n4. **Document new features** comprehensively\n5. **Submit pull requests** with detailed descriptions\n\n### Research Validation Standards\n- All physics claims must be backed by analytical benchmarks\n- Mathematical derivations should be step-by-step verifiable\n- Experimental proposals must cite realistic parameters\n- Novel concepts require thorough feasibility analysis\n\n## üôè Acknowledgments\n\n- **AlphaEvolve Architecture**: Inspiration for evolutionary discovery methods\n- **A4F Platform**: Flexible access to multiple language models\n- **Quantum Optics Community**: Benchmarks and validation from leading research groups\n- **Open Source Contributors**: Community contributions to physics validation and testing\n\n## üìû Support and Community\n\n### Getting Help\n1. **GitHub Issues**: Report bugs and request features\n2. **GitHub Discussions**: Ask questions and share research results\n3. **Documentation**: See `docs/` for detailed technical guides\n4. **Community**: Join the quantum AI research community\n\n### Research Sharing\n- Share your breakthrough discoveries with the community\n- Contribute high-quality seed research examples\n- Submit physics validation improvements\n- Propose new research categories and evaluation criteria\n\n---\n\n## üéØ Quick Start Commands\n\n**Immediate Usage** (copy and paste):\n```bash\n# Set your API key\nexport A4F_API_KEY=\"ddc-a4f-your-api-key-here\"\n\n# Run your first quantum research evolution\npython src/main.py evolve --generations 15 --population 8\n\n# View your results\npython view_results.py results/\n\n# Test without API (demo mode)\npython src/main.py evolve --demo --generations 5 --population 3\n```\n\n**Ready to discover breakthrough quantum optics research?** üöÄ\n\nStart your evolution today and let Coheron guide you to novel physics discoveries through the power of evolutionary AI!",
    "cached_at": 1750965300.1624055
  }
}