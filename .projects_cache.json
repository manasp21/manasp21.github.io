{
  "https://github.com/manasp21/MagTrace": {
    "name": "MagTrace",
    "full_name": "manasp21/MagTrace",
    "description": "Professional magnetic field analysis platform for research and industrial applications",
    "readme_description": "Professional magnetic field analysis platform for research and industrial applications Author: Manas Pandey | Developed with Claude AI assistance",
    "language": "Python",
    "stars": 1,
    "forks": 0,
    "watchers": 1,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-06-05T05:45:52Z",
    "updated_at": "2025-06-24T13:28:21Z",
    "pushed_at": "2025-06-17T14:12:08Z",
    "size": 15940,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/MagTrace",
    "clone_url": "https://github.com/manasp21/MagTrace.git",
    "ssh_url": "git@github.com:manasp21/MagTrace.git",
    "readme_content": "# MagTrace - Magnetic Field Data Analysis Platform\n\n**Professional magnetic field analysis platform for research and industrial applications**\n\n*Author: Manas Pandey | Developed with Claude AI assistance*\n\n[![Python](https://img.shields.io/badge/python-3.8+-blue.svg)](https://python.org)\n[![Django](https://img.shields.io/badge/django-4.2-green.svg)](https://djangoproject.com)\n[![Status](https://img.shields.io/badge/status-development-orange.svg)](#current-limitations)\n\n## Project Status: Development Phase\n\n**Current State:** Core functionality implemented, requires comprehensive testing and production hardening.\n\nMagTrace provides magnetic field data analysis capabilities using machine learning for anomaly detection and pattern recognition. The platform processes magnetometer sensor data (B_x, B_y, B_z components) with interactive visualization and automated classification.\n\n## Quick Start\n\n```bash\ngit clone https://github.com/manasp21/MagTrace.git\ncd MagTrace\npython3 run.py\n```\n\n**Access Points:**\n- **Main Application:** http://localhost:8000/app/\n- **API Documentation:** http://localhost:8000/api/\n- **Health Check:** http://localhost:8000/health/\n\n## Core Features (Implemented)\n\n### ‚úÖ Working Functionality\n- **Project Management** - Organize magnetic field analysis projects\n- **CSV Data Upload** - Process magnetometer readings with automatic parsing\n- **Interactive Visualization** - D3.js charts with zoom, pan, and brush selection\n- **Data Labeling** - Manual annotation of magnetic field anomalies and patterns\n- **Machine Learning Training** - Scikit-learn Random Forest classification\n- **Real-time Progress** - Live training monitoring with progress indicators\n- **RESTful API** - Complete API for programmatic access\n\n### üìä Data Format Support\n```csv\ntimestamp_pc,b_x,b_y,b_z,lat,lon,altitude,thetax,thetay,thetaz,sensor_id\n24:40.0,7746.664,9395.448,14682.022,26.5123251,80.2238068,2018,0,0,0,S963350075783\n```\n\n**Required Columns:** `timestamp_pc`, `b_x`, `b_y`, `b_z`\n**Optional Columns:** `lat`, `lon`, `altitude`, `sensor_id`, `thetax`, `thetay`, `thetaz`\n\n## Current Limitations\n\n### üö® Critical Production Gaps\n\n**1. Security**\n- ‚ùå **No authentication system** - Single-user development setup only\n- ‚ùå **No input validation** - Limited CSV format checking\n- ‚ùå **No rate limiting** - API endpoints unprotected\n- ‚ùå **Insecure file uploads** - Basic validation only\n- ‚ùå **Debug mode enabled** - Not production-ready\n\n**2. Scalability Issues**\n- ‚ùå **SQLite database** - Single-user, no concurrent access\n- ‚ùå **File upload limits** - ~100MB maximum, no chunking\n- ‚ùå **Memory limitations** - Large datasets (>50k points) cause performance issues\n- ‚ùå **No background processing** - Training blocks server threads\n- ‚ùå **Single-threaded ML** - No distributed computing support\n\n**3. Data Management**\n- ‚ùå **No data validation** - Limited error handling for malformed CSV\n- ‚ùå **No backup system** - Manual database backup required\n- ‚ùå **No data retention** - Unlimited storage consumption\n- ‚ùå **No audit logging** - No tracking of data access or modifications\n\n**4. Reliability**\n- ‚ùå **No error recovery** - Failed operations require manual cleanup\n- ‚ùå **No monitoring** - No health checks or alerting\n- ‚ùå **Development server** - Django development server not production-ready\n- ‚ùå **No load balancing** - Single point of failure\n\n## Testing Requirements\n\n### üß™ Comprehensive Testing Needed\n\n**CRITICAL:** This system requires extensive testing before any production deployment.\n\n#### Performance Testing\n- [ ] **Small datasets** (< 1,000 points) - Response time < 2 seconds\n- [ ] **Medium datasets** (1,000-10,000 points) - Memory usage < 2GB\n- [ ] **Large datasets** (> 10,000 points) - Verify decimation works correctly\n- [ ] **Concurrent users** - Test multiple simultaneous uploads\n- [ ] **Memory stress** - Monitor for memory leaks during extended use\n\n#### Functional Testing  \n- [ ] **End-to-end workflow** - Project ‚Üí Upload ‚Üí Label ‚Üí Train ‚Üí Predict\n- [ ] **API endpoints** - All CRUD operations for each model\n- [ ] **Error handling** - Invalid data, network failures, timeouts\n- [ ] **Browser compatibility** - Chrome, Firefox, Safari, Edge\n- [ ] **Data integrity** - Verify annotations persist correctly\n\n#### Security Testing\n- [ ] **Input validation** - SQL injection, XSS, file upload attacks\n- [ ] **CSRF protection** - Verify all state-changing operations protected\n- [ ] **File upload security** - Malicious file upload attempts\n- [ ] **API security** - Authentication bypass attempts\n\n#### Data Quality Testing\n- [ ] **CSV format variations** - Different timestamp formats, missing columns\n- [ ] **Magnetic field ranges** - Extreme values, negative numbers, scientific notation\n- [ ] **GPS coordinates** - Invalid lat/lon values, missing location data\n- [ ] **Large file handling** - Files approaching 100MB limit\n\n### Test Data Requirements\n\n**Minimum Test Dataset Collection:**\n1. **Small datasets** (10-100 points) - Quick validation\n2. **Medium datasets** (1,000-5,000 points) - Performance testing  \n3. **Large datasets** (10,000+ points) - Stress testing\n4. **Anomaly datasets** - Clear patterns for ML validation\n5. **Edge case datasets** - Missing values, extreme ranges, malformed data\n\n**Sample data provided:** `example/data_1.csv` (46 points) - Insufficient for comprehensive testing.\n\n## Technical Architecture\n\n### Backend Stack\n- **Framework:** Django 4.2 + Django REST Framework\n- **Database:** SQLite (development) / PostgreSQL (production required)\n- **ML Framework:** Scikit-learn 1.3.2 (TensorFlow optional, often fails)\n- **File Processing:** Pandas for CSV parsing and data manipulation\n\n### Frontend Stack  \n- **UI:** HTML5 + Vanilla JavaScript + CSS\n- **Visualization:** D3.js for interactive magnetic field charts\n- **AJAX:** Fetch API for backend communication\n\n### Key Components\n```\nbackend/\n‚îú‚îÄ‚îÄ magtrace_api/               # Main API application\n‚îÇ   ‚îú‚îÄ‚îÄ models.py              # Database models (Project, Dataset, Annotation)\n‚îÇ   ‚îú‚îÄ‚îÄ views.py               # API endpoints and business logic\n‚îÇ   ‚îú‚îÄ‚îÄ simple_training_service.py   # ML training orchestration\n‚îÇ   ‚îî‚îÄ‚îÄ serializers.py         # API data serialization\n‚îú‚îÄ‚îÄ templates/magtrace.html    # Single-page application interface\n‚îú‚îÄ‚îÄ static/js/magtrace.js      # Frontend application logic\n‚îî‚îÄ‚îÄ manage.py                  # Django management commands\n```\n\n## Production Deployment Requirements\n\n### üè≠ Production Checklist\n\n**Infrastructure:**\n- [ ] **Web Server** - Nginx/Apache with WSGI (Gunicorn/uWSGI)\n- [ ] **Database** - PostgreSQL with connection pooling\n- [ ] **Caching** - Redis for session storage and API caching\n- [ ] **File Storage** - S3/MinIO for uploaded datasets (not local filesystem)\n- [ ] **Monitoring** - Application performance monitoring (APM)\n\n**Security Hardening:**\n- [ ] **Authentication** - User management system with role-based access\n- [ ] **HTTPS** - SSL certificate and secure headers\n- [ ] **Input Validation** - Comprehensive data sanitization\n- [ ] **Rate Limiting** - API request throttling\n- [ ] **File Upload Security** - Virus scanning, type validation\n\n**Scalability:**\n- [ ] **Background Jobs** - Celery + Redis for ML training\n- [ ] **Load Balancing** - Multiple application instances\n- [ ] **Database Scaling** - Read replicas, connection pooling\n- [ ] **CDN** - Static file delivery optimization\n\n**Operational:**\n- [ ] **Backup Strategy** - Automated database and file backups\n- [ ] **Logging** - Structured application and access logs\n- [ ] **Monitoring** - Health checks, error tracking, alerting\n- [ ] **Deployment Pipeline** - CI/CD with automated testing\n\n## Development Setup\n\n### Prerequisites\n- Python 3.8+ (3.10+ recommended)\n- 8GB+ RAM (for large dataset processing)\n- Modern web browser\n\n### Installation Options\n\n**1. Quick Start (Recommended)**\n```bash\npython3 run.py  # Automated setup with virtual environment\n```\n\n**2. Manual Setup**\n```bash\ncd backend\npython3 -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Use lightweight requirements (TensorFlow often fails)\npip install -r requirements-lite.txt\n\npython manage.py migrate\npython manage.py runserver\n```\n\n### Verification\n```bash\n# Health check\ncurl http://localhost:8000/health/\n\n# Comprehensive workflow test\npython3 test_workflow.py\n```\n\n## API Overview\n\n**Core Endpoints:**\n- `POST /api/projects/` - Create magnetic field analysis project\n- `POST /api/datasets/upload/` - Upload CSV magnetometer data\n- `GET /api/datasets/{id}/data/` - Retrieve processed data with decimation\n- `POST /api/annotations/` - Create labeled data regions\n- `POST /api/training/start/` - Begin ML model training\n- `GET /api/training/status/{session_id}/` - Monitor training progress\n\n**Full API Documentation:** [docs/source/api_reference.rst](docs/source/api_reference.rst)\n\n## Known Issues\n\n### üêõ Current Bugs\n- **Training sessions** may hang with very large datasets (>20k points)\n- **Browser performance** degrades with >50 annotations on single chart\n- **CSV parsing** fails silently with some timestamp formats\n- **Memory leaks** in long-running training sessions\n\n### ‚ö†Ô∏è Reliability Issues\n- **No graceful failure** handling for interrupted operations\n- **Database locks** occur with rapid successive API calls\n- **File upload** corrupts with network interruptions\n- **Training progress** not recoverable after server restart\n\n## Development Roadmap\n\n### Phase 1: Production Readiness (High Priority)\n- [ ] **Authentication system** - User registration, login, permissions\n- [ ] **Production database** - PostgreSQL migration and optimization  \n- [ ] **Security hardening** - Input validation, rate limiting, HTTPS\n- [ ] **Error handling** - Graceful failures and recovery mechanisms\n- [ ] **Unit testing** - Comprehensive test suite beyond integration tests\n\n### Phase 2: Scalability (Medium Priority)\n- [ ] **Background processing** - Celery task queue for ML training\n- [ ] **File chunking** - Large dataset upload support (>100MB)\n- [ ] **Data validation** - Robust CSV format checking and sanitization\n- [ ] **Performance optimization** - Database query optimization, caching\n\n### Phase 3: Advanced Features (Low Priority)\n- [ ] **Model export/import** - Save/load trained models\n- [ ] **Batch processing** - Multiple dataset analysis\n- [ ] **Advanced ML algorithms** - Deep learning options\n- [ ] **Real-time data streaming** - Live magnetometer data processing\n\n## Documentation\n\n**Complete Documentation:** [GitHub Pages](https://manasp21.github.io/MagTrace/docs/index.html)\n\n**Key Resources:**\n- [Installation Guide](docs/source/installation.rst) - Setup and troubleshooting\n- [Quick Start Tutorial](docs/source/quick_start_tutorial.rst) - 10-minute walkthrough\n- [API Reference](docs/source/api_reference.rst) - Complete endpoint documentation\n- [Troubleshooting Guide](docs/source/troubleshooting.rst) - Common issues and solutions\n- [Testing Results](docs/source/testing_results.rst) - Validation and performance data\n\n## Contributing\n\n**Development Environment:**\n```bash\n# Fork repository, then:\ngit clone https://github.com/YOUR_USERNAME/MagTrace.git\ncd MagTrace/backend\nsource venv/bin/activate\npip install -r requirements-lite.txt\n\n# Run tests\npython3 test_workflow.py\npython manage.py test\n```\n\n**Code Standards:**\n- Follow Django best practices for backend development\n- Use vanilla JavaScript (no framework dependencies) for frontend\n- Include docstrings for all new functions and classes\n- Add integration tests for new API endpoints\n\n## License & Attribution\n\n**Author:** Manas Pandey  \n**Development Assistance:** Claude AI (Anthropic)  \n**License:** [Specify license]\n\n---\n\n## ‚ö†Ô∏è Important Notice\n\n**This software is in active development and not ready for production use without significant additional work.**\n\n**For Production Deployment:**\n1. Complete comprehensive testing with your specific datasets\n2. Implement authentication and security hardening\n3. Migrate to production-grade database and infrastructure\n4. Add monitoring, logging, and backup systems\n5. Conduct security audit and penetration testing\n\n**Use in controlled environments only until production readiness checklist is completed.**",
    "cached_at": 1752302457.7070022
  },
  "https://github.com/manasp21/magnav.py": {
    "name": "magnav.py",
    "full_name": "manasp21/magnav.py",
    "description": "MagNavPy is a Python library for magnetic navigation research and development. A port of magnav.jl.",
    "readme_description": "MagNavPy is a Python library for magnetic navigation research and development. It is a port of the original MagNav.jl (Julia) package, providing tools for simulating magnetic navigation scenarios, ...",
    "language": "Python",
    "stars": 1,
    "forks": 0,
    "watchers": 1,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-05-27T08:29:59Z",
    "updated_at": "2025-06-24T13:29:27Z",
    "pushed_at": "2025-06-13T07:59:17Z",
    "size": 19147,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/magnav.py",
    "clone_url": "https://github.com/manasp21/magnav.py.git",
    "ssh_url": "git@github.com:manasp21/magnav.py.git",
    "readme_content": "# MagNavPy\n\n[![PyPI version](https://img.shields.io/pypi/v/magnavpy.svg)](https://pypi.org/project/magnavpy/) <!-- Placeholder -->\n[![Build Status](https://img.shields.io/travis/com/yourusername/magnavpy.svg)](https://travis-ci.com/yourusername/magnavpy) <!-- Placeholder -->\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nMagNavPy is a Python library for magnetic navigation research and development. It is a port of the original [MagNav.jl](https://github.com/MIT-AI-Accelerator/MagNav.jl) (Julia) package, providing tools for simulating magnetic navigation scenarios, processing magnetometer data, compensating for aircraft magnetic noise, and implementing navigation filters.\n\n## Key Features\n\n*   **Data Handling**: Load, process, and manage flight path, INS, and magnetometer data, including built-in datasets.\n*   **Magnetic Anomaly Maps**: Utilities for loading, manipulating (e.g., upward continuation), and interpolating magnetic anomaly maps, with access to built-in global and regional maps.\n*   **Aeromagnetic Compensation**: Implementations of classical methods like Tolles-Lawson and advanced Neural Network-based models for compensating aircraft magnetic noise.\n*   **Navigation Algorithms**: Tools for magnetic navigation filtering, including Extended Kalman Filters (EKF) and the MagNav filter model, along with performance analysis using the Cram√©r‚ÄìRao Lower Bound (CRLB).\n*   **Simulation & Analysis**: Simulate magnetic navigation scenarios and analyze performance.\n*   **Data Visualization**: Plotting functions to visualize flight data, magnetic maps, and filter outputs.\n\n## Core Concepts\n\nMagNavPy utilizes several key data structures to organize and manage data:\n\n*   [`Map`](magnavpy/common_types.py:9): Represents a magnetic anomaly map.\n*   [`Traj`](magnavpy/magnav.py:40): Stores flight trajectory data.\n*   [`INS`](magnavpy/magnav.py:43): Holds Inertial Navigation System data.\n*   [`XYZ`](magnavpy/magnav.py:48): A general structure for flight data including position, time, and magnetic field measurements.\n*   [`EKF_RT`](magnavpy/ekf.py:81): Represents the state of a Real-Time Extended Kalman Filter.\n*   [`CompParams`](magnavpy/compensation.py:87), [`LinCompParams`](magnavpy/compensation.py:90), [`NNCompParams`](magnavpy/compensation.py:93): Structures for holding parameters for different compensation models.\n\n## Original Project\n\nThis project is a Python conversion of the [MagNav.jl](https://github.com/MIT-AI-Accelerator/MagNav.jl) library, originally developed by the MIT AI Accelerator. We acknowledge and thank the original authors for their foundational work.\n\n## Installation\n\n### Prerequisites\n\n*   Python 3.9 or higher.\n*   **GDAL**: This library depends on GDAL.\n    *   **For Windows users:** It is strongly recommended to install GDAL using pre-compiled wheels from sources like Christoph Gohlke's Unofficial Windows Binaries for Python Extension Packages. Ensure you download the wheel compatible with your Python version (e.g., Python 3.13) and system architecture (e.g., `win_amd64`). Direct installation via `pip install gdal` can often lead to compilation issues on Windows. After downloading the appropriate `.whl` file, you can install it using pip (e.g., `pip install GDAL-3.9.0-cp313-cp313-win_amd64.whl`).\n    *   **For other operating systems:** Please refer to the [official GDAL installation guide](https://gdal.org/download.html#binaries) for instructions.\n\n### Project Dependencies\n\nBeyond the prerequisites, MagNavPy relies on several Python packages for its functionality. All required packages are listed in the [`requirements.txt`](requirements.txt:0) file and can be installed as described in the installation steps. Key dependencies include:\n\n*   **gdal**: For geospatial data operations (Python bindings, requires system-level GDAL).\n*   **pandas**: For data manipulation and analysis.\n*   **torch**: For deep learning models and tensor computations.\n*   **matplotlib**: For plotting and visualization.\n*   **h5py**: For interacting with HDF5 files.\n*   **scipy**: For scientific and technical computing.\n*   **jax**: For high-performance numerical computing and machine learning research.\n*   **toml**: For parsing TOML configuration files.\n*   **scikit-learn**: For machine learning tools.\n*   **statsmodels**: For statistical modeling.\n*   **pytest**: For running the test suite.\n\nPlease ensure GDAL is installed on your system *before* running `pip install -r requirements.txt`.\n\n### Steps\n\n1.  **Clone the repository (if you haven't already):**\n    ```bash\n    git clone https://github.com/yourusername/MagNavPy.git # Replace with actual URL\n    ```\n    Navigate into the cloned repository's root directory (where `requirements.txt` is located). All subsequent installation commands should be run from this directory.\n\n2.  **Create and activate a Python virtual environment (recommended):**\n    ```bash\n    python -m venv venv\n    # On Windows\n    # venv\\Scripts\\activate\n    # On macOS/Linux\n    source venv/bin/activate\n    ```\n\n3.  **Install dependencies:**\n    Ensure your virtual environment is active and you are in the repository root directory. To install the required Python packages, run:\n    ```bash\n    pip install -r requirements.txt\n    ```\n    If you are developing the library, you might want to install it in editable mode:\n    ```bash\n    pip install -e .\n    ```\n\n## Data and Artifact Management\n\nMagNavPy requires specific data artifacts, such as magnetic anomaly maps and flight datasets, to function correctly. Currently, these artifacts are not managed or downloaded automatically by this Python port.\n\n**Manual Placement:**\nUsers are required to manually obtain these artifacts and place them in a directory named `artifacts_data`. This directory should be located at the **root of the `MagNavPy` repository** (e.g., if you cloned the repository into a folder named `MagNavPy`, the path would be `MagNavPy/artifacts_data/`).\n\n**Obtaining Artifacts:**\nInformation regarding the required artifacts and their original sources can be found in the [`Artifacts.toml`](../MagNav.jl/Artifacts.toml:1) file of the original [MagNav.jl project](https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/main/Artifacts.toml). Please refer to this file to identify and download the necessary data.\n\n## Usage\n\nMagNavPy provides functions for various stages of magnetic navigation processing. Here are examples of key functions:\n\n**Data Loading:**\nUse functions like [`create_xyz0`](magnavpy/create_xyz.py:9), [`get_xyz20`](magnavpy/create_xyz.py:11), or [`get_XYZ`](magnavpy/create_xyz.py:13) to load flight data. Built-in datasets like `sgl_2020_train` and `sgl_2021_train` are also available.\n\n**Map Handling:**\nLoad magnetic anomaly maps using [`get_map`](magnavpy/map_utils.py:9). Functions like [`upward_fft`](magnavpy/map_utils.py:25) are available for map manipulation.\n\n**Aeromagnetic Compensation:**\nTrain and test compensation models using [`comp_train`](magnavpy/compensation.py:16) and [`comp_test`](magnavpy/compensation.py:21). The library supports classical Tolles-Lawson and various Neural Network-based models (e.g., `:m1`, `:m2a`, `:m2b`, `:m2c`, `:m2d`, `:m3s`, `:m3v`).\n\n**Navigation Filtering:**\nRun navigation filters, such as the Extended Kalman Filter, using the [`run_filt`](magnavpy/magnav.py:33) function.\n\nFor more detailed examples, please refer to the `examples/` directory (if available) or the test scripts in the `tests/` directory.\n\n## Documentation\n\nFull documentation, including API references and usage guides, is generated using Sphinx.\n\nTo build the documentation locally:\n```bash\ncd docs\nmake html\n```\nThen, open `docs/build/html/index.html` in your web browser.\n\nThe documentation may also be hosted online in the future.\n\n## Testing\n\nTo run the test suite, navigate to the root directory of the project and use `pytest`:\n```bash\npytest tests/\n```\nThis will execute all tests defined in the `tests/` directory.\n\n## Current Status and Known Issues\n\nThis Python port of MagNav.jl is an ongoing development effort. While significant progress has been made, users should be aware of the following:\n\n*   **Ongoing Porting:** The library is actively being ported from Julia. Not all features and functionalities of the original MagNav.jl may be fully implemented or tested.\n*   **Environment and Imports:** Initial challenges with setting up the Python environment, particularly GDAL installation and resolving relative import paths within the `magnavpy` package, have been largely addressed.\n*   **Testing Coverage:** The original task mentioned \"pytest errors and otherwise.\" A comprehensive review and execution of the `pytest` test suite to ensure full functionality and identify remaining issues is still pending.\n*   **Manual Data Artifacts:** As detailed in the \"Data and Artifact Management\" section, data artifacts are currently handled manually. There is no automated download or management system within this Python port.\n*   **Documentation:** Documentation is being actively developed. While Sphinx documentation is available, it may not yet cover all aspects of the Python port comprehensively.\n\n## Contributing\n\nContributions are welcome! If you'd like to contribute, please feel free to open an issue to discuss your ideas or submit a pull request.\n(More detailed contribution guidelines may be added to a `CONTRIBUTING.md` file in the future.)\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details (assuming a `LICENSE` file will be added, or state \"MIT License\" directly). The original MagNav.jl project is also licensed under the MIT License.\n\n## Acknowledgements\n\n*   The developers and contributors of the original [MagNav.jl](https://github.com/MIT-AI-Accelerator/MagNav.jl).\n*   The broader open-source community for the tools and libraries that make this project possible.",
    "cached_at": 1752302460.9283817
  },
  "https://github.com/manasp21/PsiAnimator-MCP": {
    "name": "PsiAnimator-MCP",
    "full_name": "manasp21/PsiAnimator-MCP",
    "description": "A MCP-Server for Quantum Physics Simulation and Animation",
    "readme_description": "Quantum Physics Simulation and Animation Server A Model Context Protocol (MCP) server that integrates QuTip (Quantum Toolbox in Python) for quantum physics computations with Manim (Mathematical Ani...",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": "MIT License",
    "created_at": "2025-06-24T10:40:51Z",
    "updated_at": "2025-06-27T08:26:49Z",
    "pushed_at": "2025-06-27T08:26:47Z",
    "size": 241,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/PsiAnimator-MCP",
    "clone_url": "https://github.com/manasp21/PsiAnimator-MCP.git",
    "ssh_url": "git@github.com:manasp21/PsiAnimator-MCP.git",
    "readme_content": "# PsiAnimator-MCP\n\n**Quantum Physics Simulation and Animation Server**\n\nA Model Context Protocol (MCP) server that integrates [QuTip](https://qutip.org/) (Quantum Toolbox in Python) for quantum physics computations with [Manim](https://www.manim.community/) (Mathematical Animation Engine) for visualization.\n\n## Features\n\n- üî¨ **Quantum Physics Engine**: Complete state management, time evolution, and measurement tools\n- üé¨ **Manim Animations**: Publication-quality visualizations with quantum-specific scenes\n- üîå **MCP Integration**: Seamless integration with MCP-compatible clients\n- üßÆ **Scientific Computing**: Built on NumPy, SciPy, and QuTip for accuracy\n- üìä **Visualization Types**: Bloch spheres, Wigner functions, state tomography, circuits\n- üéì **Educational Focus**: Perfect for quantum mechanics education and research\n\n## Installation\n\n### Quick Install\n\n#### Option 1: One-line install (Unix/macOS)\n```bash\ncurl -fsSL https://raw.githubusercontent.com/username/PsiAnimator-MCP/main/scripts/install.sh | bash\n```\n\n#### Option 2: PowerShell (Windows)\n```powershell\niwr https://raw.githubusercontent.com/username/PsiAnimator-MCP/main/scripts/install.ps1 | iex\n```\n\n#### Option 3: pip (when available on PyPI)\n```bash\n# Core installation (quantum computation only)\npip install psianimator-mcp\n\n# Full installation with animation support\npip install \"psianimator-mcp[animation]\"\n\n# Development installation\npip install \"psianimator-mcp[dev,animation]\"\n```\n\n#### Option 4: From source\n```bash\ngit clone https://github.com/username/PsiAnimator-MCP.git\ncd PsiAnimator-MCP\n./scripts/install.sh --from-source\n```\n\n### Prerequisites\n\n- Python ‚â• 3.10\n- Git (for development installation)\n\n**For animation features:**\n- LaTeX (for advanced mathematical rendering)\n- FFmpeg (for video generation)\n- Cairo graphics library (for high-quality rendering)\n\n### Installation Options Explained\n\n**üöÄ Core Installation** (Recommended for most users)\n```bash\npip install psianimator-mcp\n```\n- Includes all quantum computation features\n- MCP server functionality\n- QuTip, NumPy, SciPy for quantum physics\n- Works immediately without system dependencies\n\n**üé¨ Animation Installation** (For visualization)\n```bash\npip install \"psianimator-mcp[animation]\"\n```\n- Everything from core installation\n- Manim for generating animations\n- Requires system dependencies (LaTeX, FFmpeg)\n- Larger download and installation time\n\n**üîß Development Installation**\n```bash\ngit clone https://github.com/username/PsiAnimator-MCP.git\ncd PsiAnimator-MCP\npip install -e \".[dev,animation]\"\n```\n\n### Why Animation is Optional\n\nAnimation features (Manim) are kept optional because:\n\n- **Heavy Dependencies**: Manim requires LaTeX, FFmpeg, and Cairo which can be several GB\n- **Installation Complexity**: System dependencies can fail on different platforms\n- **Use Case Separation**: Many users only need quantum computation, not visualization\n- **CI/Testing Reliability**: Core features can be tested without system dependencies\n- **Disk Space**: Core installation is ~100MB vs ~2GB+ with full animation stack\n\n### Dependencies\n\n**Core dependencies** (automatically installed):\n- QuTip ‚â• 4.7.0 (quantum physics computations)\n- MCP ‚â• 1.0.0 (Model Context Protocol)\n- NumPy, SciPy, matplotlib (scientific computing)\n- Pydantic, aiohttp (async web framework)\n\n**Animation dependencies** (optional extras):\n- Manim ‚â• 0.18.0 (mathematical animations)\n- h5py ‚â• 3.9.0 (data storage)\n- pandas ‚â• 2.0.0 (data analysis)\n\n### Post-Installation Setup\n\nAfter installation, run the setup command:\n```bash\npsianimator-mcp setup\n```\n\nThis will:\n- Create configuration directory (`~/.config/psianimator-mcp/`)\n- Copy example configuration file\n- Test installation and show feature availability\n- Provide Claude Desktop integration instructions\n\n### Verifying Installation\n\nCheck your installation status:\n```bash\npython -c \"import psianimator_mcp; print(f'‚úÖ Core: OK, Animation: {psianimator_mcp.is_animation_available()}')\"\n```\n\nExpected outputs:\n- `‚úÖ Core: OK, Animation: True` - Full installation with animations\n- `‚úÖ Core: OK, Animation: False` - Core installation only\n\n### Troubleshooting\n\n**Import Errors**\n```bash\n# If you get \"No module named 'psianimator_mcp'\"\npip install psianimator-mcp\n\n# If you get animation-related errors\npip install \"psianimator-mcp[animation]\"\n```\n\n**Animation Dependencies**\n```bash\n# Ubuntu/Debian\nsudo apt-get install texlive-latex-base ffmpeg libcairo2-dev\n\n# macOS\nbrew install mactex ffmpeg cairo\n\n# Windows\n# Install MiKTeX, FFmpeg from official websites\n```\n\n## Claude Desktop Integration\n\n### Automatic Configuration\n\nGenerate Claude Desktop configuration:\n```bash\npsianimator-mcp claude-config\n```\n\n### Manual Configuration\n\nAdd to your Claude Desktop configuration file:\n\n**Windows:** `%USERPROFILE%\\AppData\\Roaming\\Claude\\claude_desktop_config.json`\n**macOS:** `~/Library/Application Support/Claude/claude_desktop_config.json`\n**Linux:** `~/.config/claude-desktop/claude_desktop_config.json`\n\n```json\n{\n  \"mcpServers\": {\n    \"psianimator-mcp\": {\n      \"command\": \"python3\",\n      \"args\": [\"-m\", \"psianimator_mcp.cli\", \"serve\"],\n      \"env\": {\n        \"PSIANIMATOR_CONFIG\": \"~/.config/psianimator-mcp/config.json\"\n      }\n    }\n  }\n}\n```\n\n**Note:** Restart Claude Desktop after configuration changes.\n\n## Quick Start\n\n### 1. Start the Server\n\n**Default (serves via MCP protocol):**\n```bash\npsianimator-mcp\n```\n\n**Stdio transport explicitly:**\n```bash\npsianimator-mcp serve --transport stdio\n```\n\n**WebSocket transport:**\n```bash\npsianimator-mcp serve --transport websocket --port 3000\n```\n\n### 2. Test Installation\n\n```bash\npsianimator-mcp test\n```\n\n### 3. Basic Usage Example\n\n```python\nimport asyncio\nfrom psianimator_mcp.tools.quantum_state_tools import create_quantum_state\nfrom psianimator_mcp.tools.measurement_tools import measure_observable\nfrom psianimator_mcp.server.config import MCPConfig\n\nasync def basic_example():\n    config = MCPConfig()\n    \n    # Create a qubit in |0‚ü© state\n    result = await create_quantum_state({\n        'state_type': 'pure',\n        'system_dims': [2],\n        'parameters': {'state_indices': [0]},\n        'basis': 'computational'\n    }, config)\n    \n    state_id = result['state_id']\n    \n    # Measure ‚ü®œÉz‚ü©\n    measurement = await measure_observable({\n        'state_id': state_id,\n        'observable': 'sigmaz',\n        'measurement_type': 'expectation'\n    }, config)\n    \n    print(f\"‚ü®œÉz‚ü© = {measurement['measurement_results']['expectation_value']}\")\n\nasyncio.run(basic_example())\n```\n\n## MCP Tools\n\n### 1. `create_quantum_state`\nCreate quantum states of various types:\n- **Pure states**: |œà‚ü© (ket vectors)\n- **Mixed states**: œÅ (density matrices)\n- **Coherent states**: |Œ±‚ü© (harmonic oscillator)\n- **Squeezed states**: reduced uncertainty\n- **Thermal states**: finite temperature\n- **Fock states**: definite photon number\n\n### 2. `evolve_quantum_system`\nTime evolution with multiple methods:\n- **Unitary**: Schr√∂dinger equation (closed systems)\n- **Master equation**: Lindblad form (open systems)\n- **Monte Carlo**: Quantum trajectories\n- **Stochastic**: Continuous measurement\n\n### 3. `measure_observable`\nQuantum measurements and analysis:\n- **Expectation values**: ‚ü®O‚ü©\n- **Variances**: Œî¬≤O\n- **Probability distributions**: P(outcome)\n- **Correlation functions**: ‚ü®A‚ü©‚ü®B‚ü©\n\n### 4. `animate_quantum_process`\nGenerate Manim animations:\n- **Bloch sphere evolution**: Qubit dynamics\n- **Wigner functions**: Phase space representation\n- **State tomography**: Density matrix visualization\n- **Circuit execution**: Gate sequence animation\n- **Energy levels**: Population dynamics\n\n### 5. `quantum_gate_sequence`\nApply quantum gates with visualization:\n- **Single-qubit gates**: Pauli, Hadamard, rotations\n- **Two-qubit gates**: CNOT, CZ, SWAP\n- **Parameterized gates**: RX, RY, RZ with custom angles\n- **Circuit visualization**: Step-by-step animation\n\n### 6. `calculate_entanglement`\nCompute entanglement measures:\n- **Von Neumann entropy**: S(œÅ) = -Tr(œÅ log œÅ)\n- **Concurrence**: Two-qubit entanglement measure\n- **Negativity**: Partial transpose criterion\n- **Mutual information**: I(A:B)\n\n## Configuration\n\nConfigure via environment variables or `MCPConfig`:\n\n```python\nfrom psianimator_mcp.server.config import MCPConfig\n\nconfig = MCPConfig(\n    quantum_precision=1e-12,\n    max_hilbert_dimension=1024,\n    animation_cache_size=100,\n    output_directory=\"./output\",\n    render_backend=\"cairo\"\n)\n```\n\n### Environment Variables\n\nConfigure PsiAnimator-MCP via environment variables:\n\n**Server Configuration:**\n- `PSIANIMATOR_CONFIG` - Path to configuration file\n- `PSIANIMATOR_TRANSPORT` - Transport protocol (stdio/websocket)\n- `PSIANIMATOR_HOST` - Host for WebSocket transport\n- `PSIANIMATOR_PORT` - Port for WebSocket transport\n\n**Quantum Settings:**\n- `PSIANIMATOR_QUANTUM_PRECISION` - Quantum computation precision\n- `PSIANIMATOR_MAX_HILBERT_DIM` - Maximum Hilbert space dimension\n- `PSIANIMATOR_OUTPUT_DIR` - Output directory for animations\n\nExample:\n```bash\nexport PSIANIMATOR_TRANSPORT=websocket\nexport PSIANIMATOR_PORT=3001\npsianimator-mcp\n```\n\n## CLI Commands\n\nPsiAnimator-MCP provides several CLI commands:\n\n```bash\npsianimator-mcp                    # Start server (default: stdio)\npsianimator-mcp serve              # Start server with options\npsianimator-mcp config             # Show current configuration\npsianimator-mcp setup              # Run post-installation setup\npsianimator-mcp test               # Test installation\npsianimator-mcp claude-config      # Generate Claude Desktop config\npsianimator-mcp examples           # Show usage examples\npsianimator-mcp version            # Show version\npsianimator-mcp --help             # Show help\n```\n\n### Command Examples\n\n**Start with custom config:**\n```bash\npsianimator-mcp serve --config /path/to/config.json\n```\n\n**WebSocket mode:**\n```bash\npsianimator-mcp serve --transport websocket --host 0.0.0.0 --port 8080\n```\n\n**Verbose logging:**\n```bash\npsianimator-mcp serve -vvv\n```\n\n## Examples\n\nComprehensive examples are provided in the `examples/` directory:\n\n- `basic_usage.py` - Core functionality walkthrough\n- Bell state creation and entanglement analysis\n- Harmonic oscillator coherent state evolution\n- Multi-qubit quantum circuits\n\nRun examples:\n```bash\npython examples/basic_usage.py\n```\n\n## Development\n\n### Setup Development Environment\n\n```bash\ngit clone https://github.com/username/PsiAnimator-MCP.git\ncd PsiAnimator-MCP\npip install -e \".[dev]\"\npre-commit install\n```\n\n### Run Tests\n\n```bash\npytest tests/\n```\n\n### Code Quality\n\n```bash\nblack src/ tests/\nisort src/ tests/\nmypy src/\n```\n\n## Architecture\n\n```\nPsiAnimator-MCP/\n‚îú‚îÄ‚îÄ src/psianimator_mcp/\n‚îÇ   ‚îú‚îÄ‚îÄ server/          # MCP server implementation\n‚îÇ   ‚îú‚îÄ‚îÄ quantum/         # Quantum physics engine\n‚îÇ   ‚îú‚îÄ‚îÄ animation/       # Manim visualization components\n‚îÇ   ‚îî‚îÄ‚îÄ tools/           # MCP tool implementations\n‚îú‚îÄ‚îÄ tests/               # Comprehensive test suite\n‚îú‚îÄ‚îÄ examples/            # Usage examples\n‚îî‚îÄ‚îÄ docs/               # Documentation\n```\n\n## Limitations\n\n- Animation rendering requires sufficient system resources\n- Large Hilbert spaces (>1024 dimensions) may impact performance\n- Some advanced quantum error correction features are not yet implemented\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n\n## Contributing\n\nWe welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for:\n- Development guidelines\n- Code standards\n- Testing requirements\n- Pull request process\n\n## Support\n\n- **Documentation**: See `docs/API_REFERENCE.md`\n- **Examples**: Check `examples/` directory\n- **Issues**: Report bugs via GitHub issues",
    "cached_at": 1752302465.1325758
  },
  "https://github.com/manasp21/Coheron": {
    "name": "Coheron",
    "full_name": "manasp21/Coheron",
    "description": "An evolutionary AI system for solving challenging problems in Atomic, Molecular, and Optical Physics",
    "readme_description": "An evolutionary AI system for solving challenging problems in Atomic, Molecular, and Optical Physics Coheron uses advanced language models and evolutionary algorithms to tackle specific physics cha...",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": "MIT License",
    "created_at": "2025-06-22T16:08:31Z",
    "updated_at": "2025-06-29T00:36:28Z",
    "pushed_at": "2025-06-29T20:32:51Z",
    "size": 686,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/Coheron",
    "clone_url": "https://github.com/manasp21/Coheron.git",
    "ssh_url": "git@github.com:manasp21/Coheron.git",
    "readme_content": "# Coheron\n\n**An evolutionary AI system for solving challenging problems in Atomic, Molecular, and Optical Physics**\n\nCoheron uses advanced language models and evolutionary algorithms to tackle specific physics challenges in quantum optics, cavity QED, optomechanics, and quantum sensing. Instead of generating generic research ideas, Coheron evolves solutions toward measurable physics targets like \"achieve g/Œ∫ > 1000 at room temperature\" or \"generate 20 dB squeezed light.\"\n\n[![Python 3.9+](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/downloads/)\n[![A4F API](https://img.shields.io/badge/A4F-Compatible-green.svg)](https://www.a4f.co/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n## What Makes Coheron Unique\n\nüéØ **Problem-Focused Evolution**: Evolves solutions toward specific physics targets rather than generating generic ideas\n\nüî¨ **Real Physics Challenges**: Tackle unsolved problems like room temperature strong coupling and 20 dB squeezing  \n\nüìä **Measurable Progress**: Track progress with physics parameters (coupling strengths, Q factors, cooperativities)\n\nüß¨ **Breakthrough Detection**: Automatically identifies when solutions achieve target parameters\n\nüìö **Physics Knowledge Base**: Comprehensive database of atomic data, cavity designs, and experimental records\n\n## Quick Demo\n\n```bash\n# Install and test the system\ngit clone <repository-url>\ncd Coheron\npip install -r requirements.txt\n\n# See available physics problems\npython src/main.py list-problems\n\n# Solve a specific problem (demo mode - no API key needed)\npython src/main.py solve-problem room_temp_cavity_qed --demo --generations 10\n\n# Get problem details\npython src/main.py problem-info room_temp_cavity_qed\n```\n\n## Installation Instructions\n\n### Prerequisites\n\n- **Python 3.9+** (required)\n- **API Key** (optional - can use demo mode without API)\n\n### Windows Installation\n\n#### Option 1: Native Windows\n```powershell\n# Install Python from python.org if not already installed\n# Verify Python installation\npython --version\n\n# Clone repository\ngit clone <repository-url>\ncd Coheron\n\n# Create virtual environment (recommended)\npython -m venv venv\nvenv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n#### Option 2: Windows Subsystem for Linux (WSL)\n```bash\n# In WSL terminal\nsudo apt update\nsudo apt install python3 python3-pip python3-venv git\n\n# Clone and setup\ngit clone <repository-url>\ncd Coheron\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n#### Option 3: Anaconda/Miniconda (Windows)\n```powershell\n# Create conda environment\nconda create -n coheron python=3.11\nconda activate coheron\n\n# Clone repository\ngit clone <repository-url>\ncd Coheron\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n### macOS Installation\n\n#### Option 1: Homebrew\n```bash\n# Install Python via Homebrew\nbrew install python git\n\n# Clone repository\ngit clone <repository-url>\ncd Coheron\n\n# Create virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n#### Option 2: System Python\n```bash\n# Use built-in Python (macOS 10.15+)\ngit clone <repository-url>\ncd Coheron\n\n# Create virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n#### Option 3: Conda (macOS)\n```bash\n# Install Miniconda if not already installed\ncurl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh\nbash Miniconda3-latest-MacOSX-x86_64.sh\n\n# Create environment\nconda create -n coheron python=3.11\nconda activate coheron\n\n# Clone and install\ngit clone <repository-url>\ncd Coheron\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n### Linux Installation\n\n#### Ubuntu/Debian\n```bash\n# Install dependencies\nsudo apt update\nsudo apt install python3 python3-pip python3-venv git\n\n# Clone repository\ngit clone <repository-url>\ncd Coheron\n\n# Create virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n#### CentOS/RHEL/Fedora\n```bash\n# For CentOS/RHEL\nsudo yum install python3 python3-pip git\n# OR for Fedora\nsudo dnf install python3 python3-pip git\n\n# Clone repository\ngit clone <repository-url>\ncd Coheron\n\n# Create virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n#### Arch Linux\n```bash\n# Install dependencies\nsudo pacman -S python python-pip git\n\n# Clone repository\ngit clone <repository-url>\ncd Coheron\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Test installation\npython src/main.py list-problems\n```\n\n## API Configuration (Optional)\n\nCoheron can work in demo mode without an API key, but for full functionality:\n\n### Get API Key\n1. Sign up at [A4F.co](https://www.a4f.co/)\n2. Get your API key (format: `ddc-a4f-...`)\n\n### Set API Key\n\n**Windows (Command Prompt):**\n```cmd\nset A4F_API_KEY=ddc-a4f-your-api-key-here\n```\n\n**Windows (PowerShell):**\n```powershell\n$env:A4F_API_KEY = \"ddc-a4f-your-api-key-here\"\n```\n\n**macOS/Linux:**\n```bash\nexport A4F_API_KEY=\"ddc-a4f-your-api-key-here\"\n```\n\n**Permanent Setup (add to your shell profile):**\n```bash\n# For bash users (add to ~/.bashrc)\necho 'export A4F_API_KEY=\"ddc-a4f-your-api-key-here\"' >> ~/.bashrc\n\n# For zsh users (add to ~/.zshrc)  \necho 'export A4F_API_KEY=\"ddc-a4f-your-api-key-here\"' >> ~/.zshrc\n\n# For fish users (add to ~/.config/fish/config.fish)\necho 'set -x A4F_API_KEY \"ddc-a4f-your-api-key-here\"' >> ~/.config/fish/config.fish\n```\n\n## Physics Problems Available\n\nCoheron comes with 6 challenging AMO physics problems ready to solve:\n\n### 1. Room Temperature Cavity QED (`room_temp_cavity_qed`)\n**Challenge**: Achieve strong coupling regime (g > ‚àöŒ∫Œ≥) at 300K\n- **Target**: Coupling strength g > 1 GHz, Q > 10M, Cooperativity > 1000\n- **Difficulty**: Expert\n- **Applications**: Quantum computing, single photon sources\n\n### 2. 20 dB Squeezed Light (`squeezed_light_20db`)\n**Challenge**: Generate optical squeezed states with >20 dB noise reduction\n- **Target**: Squeezing > 20 dB, Detection efficiency > 99%, Bandwidth > 100 MHz\n- **Difficulty**: Expert  \n- **Applications**: Gravitational wave detection, quantum sensing\n\n### 3. Ground State Cooling (`optomech_ground_state`)\n**Challenge**: Cool macroscopic oscillator to quantum ground state\n- **Target**: Phonon number < 0.1, Mass > 1 picogram, Cooperativity > 100\n- **Difficulty**: Expert\n- **Applications**: Macroscopic quantum mechanics, quantum transduction\n\n### 4. Single Photon Purity (`single_photon_purity`)\n**Challenge**: Deterministic single photons with 99.9% purity\n- **Target**: Purity > 99.9%, Collection efficiency > 90%, Rate > 1 GHz\n- **Difficulty**: Hard\n- **Applications**: Quantum computing, quantum communication\n\n### 5. Quantum Memory Fidelity (`quantum_memory_fidelity`)\n**Challenge**: Store quantum states with >99.9% fidelity for milliseconds\n- **Target**: Storage fidelity > 99.9%, Retrieval fidelity > 99.9%, Time > 1 ms\n- **Difficulty**: Hard\n- **Applications**: Quantum networks, quantum repeaters\n\n### 6. Heisenberg-Limited Sensing (`quantum_sensing_limit`)\n**Challenge**: Achieve 1/N sensitivity scaling with entangled particles\n- **Target**: Enhancement > 10x SQL, Particles > 1000, Coherence > 1 ms\n- **Difficulty**: Expert\n- **Applications**: Atomic clocks, magnetometry, navigation\n\n## Usage Guide\n\n### Basic Commands\n\n```bash\n# List all available physics problems\npython src/main.py list-problems\n\n# Get detailed information about a specific problem\npython src/main.py problem-info room_temp_cavity_qed\n\n# Solve a problem (demo mode - no API needed)\npython src/main.py solve-problem room_temp_cavity_qed --demo --generations 20\n\n# Solve with full AI assistance (requires API key)\npython src/main.py solve-problem squeezed_light_20db --generations 50 --model \"anthropic/claude-3.5-sonnet\"\n\n# Track progress of a solving session\npython src/main.py solution-progress room_temp_cavity_qed\n\n# Test the system\npython src/main.py test --all\n```\n\n### Advanced Usage\n\n```bash\n# Solve multiple problems in parallel\npython src/main.py solve-problem room_temp_cavity_qed --generations 30 --population 15 &\npython src/main.py solve-problem squeezed_light_20db --generations 30 --population 15 &\n\n# Compare different AI models on same problem\npython src/main.py solve-problem single_photon_purity --model \"provider-5/gemini-2.5-flash-preview-04-17\" --generations 25\npython src/main.py solve-problem single_photon_purity --model \"anthropic/claude-3.5-sonnet\" --generations 25\n\n# Export results for analysis\npython src/main.py export-results room_temp_cavity_qed --format json --output cavity_qed_results.json\n\n# Create custom problem library\npython src/main.py create-problem-library my_problems/\n```\n\n### Example: Solving Room Temperature Cavity QED\n\n```bash\n# Step 1: Understand the problem\npython src/main.py problem-info room_temp_cavity_qed\n\n# Step 2: Start solving (demo mode first)\npython src/main.py solve-problem room_temp_cavity_qed --demo --generations 15\n\n# Step 3: Try with AI assistance\nexport A4F_API_KEY=\"your-api-key\"\npython src/main.py solve-problem room_temp_cavity_qed --generations 30 --model \"anthropic/claude-3.5-sonnet\"\n\n# Step 4: Monitor progress\npython src/main.py solution-progress room_temp_cavity_qed\n\n# Step 5: Export breakthrough solutions\npython src/main.py export-solutions room_temp_cavity_qed --breakthrough-only\n```\n\n## How It Works\n\n### 1. Problem Definition\nEach physics problem is defined with:\n- **Target Parameters**: Specific measurable goals (e.g., g > 1 GHz)\n- **Constraints**: Physics limitations (energy conservation, uncertainty principle)\n- **Evaluation Criteria**: How solutions are scored\n- **Background Context**: Physics knowledge and current records\n\n### 2. Solution Evolution\nThe system evolves solutions through generations:\n1. **Generate** initial solution population\n2. **Evaluate** each solution against physics targets\n3. **Select** best performing solutions\n4. **Mutate** and crossover to create new solutions\n5. **Repeat** until breakthrough achieved or generations complete\n\n### 3. Physics Evaluation\nSolutions are scored on:\n- **Parameter Achievement**: How well they meet target physics parameters\n- **Physics Validity**: Compliance with fundamental physics laws\n- **Experimental Feasibility**: Realistic with current technology\n- **Innovation**: Novel approaches and improvements\n\n### 4. Breakthrough Detection\nSystem automatically detects when solutions:\n- Achieve all target parameters (breakthrough threshold)\n- Make significant progress (progress threshold)\n- Discover novel physics regimes\n- Exceed current experimental records\n\n## Physics Knowledge Database\n\nCoheron includes comprehensive physics knowledge:\n\n### Atomic Data\n- **Alkali Atoms**: Rb87, Cs133, Li6 with transition wavelengths, linewidths, magic wavelengths\n- **Alkaline Earth**: Ca40, Sr88 with clock transitions and intercombination lines\n- **Rydberg States**: Scaling laws and applications\n\n### Cavity Designs\n- **Fabry-Perot Cavities**: Linear and ring resonators with typical parameters\n- **Microresonators**: Microspheres, microtoroids, photonic crystals\n- **Superconducting Cavities**: 3D resonators for circuit QED\n\n### Experimental Records\n- **Cavity QED**: Strongest coupling (1.5√ó10^7 Hz), highest cooperativity (2.7√ó10^5)\n- **Squeezed Light**: Best squeezing (-15 dB), continuous wave records\n- **Optomechanics**: Lowest phonon numbers, highest cooperativities\n- **Quantum Memory**: Longest storage times, highest fidelities\n\n### Physical Constants\n- **Fundamental Constants**: All CODATA values with full precision\n- **Derived Constants**: Rydberg energy, Bohr magneton, etc.\n- **Typical Ranges**: Expected parameter ranges for different physics regimes\n\n## Troubleshooting\n\n### Common Issues\n\n**\"Python command not found\"**\n- Windows: Make sure Python is in your PATH or use `py` instead of `python`\n- macOS/Linux: Use `python3` instead of `python`\n\n**\"Module not found\" errors**\n```bash\n# Make sure you're in the virtual environment\nsource venv/bin/activate  # Linux/macOS\nvenv\\Scripts\\activate     # Windows\n\n# Reinstall dependencies\npip install -r requirements.txt\n```\n\n**API connection errors**\n```bash\n# Verify API key is set\necho $A4F_API_KEY  # Linux/macOS\necho %A4F_API_KEY% # Windows\n\n# Test with demo mode first\npython src/main.py solve-problem room_temp_cavity_qed --demo --generations 5\n```\n\n**Unicode/encoding errors (Windows)**\n```bash\n# Set proper encoding\nset PYTHONIOENCODING=utf-8\n\n# Or use demo mode\npython src/main.py solve-problem room_temp_cavity_qed --demo\n```\n\n**Permission errors**\n```bash\n# Don't use sudo with pip in virtual environment\n# If using system Python, create virtual environment instead\npython -m venv venv\nsource venv/bin/activate  # Linux/macOS\npip install -r requirements.txt\n```\n\n### Platform-Specific Tips\n\n**Windows:**\n- Use PowerShell or Command Prompt (not Git Bash for environment variables)\n- Install Python from python.org for best compatibility\n- Consider using WSL for Linux-like environment\n\n**macOS:**\n- Install Xcode command line tools: `xcode-select --install`\n- Use Homebrew for Python: `brew install python`\n- M1/M2 Macs: All dependencies are compatible\n\n**Linux:**\n- Install python3-dev for some dependencies: `sudo apt install python3-dev`\n- Use system package manager for Python: `sudo apt install python3 python3-pip`\n- SELinux users: May need to set appropriate contexts\n\n## Adding Custom Problems\n\n### 1. Create Problem YAML File\n```yaml\n# my_custom_problem.yaml\nid: my_problem\ntitle: \"My Custom Physics Problem\"\ncategory: quantum_optics\ndescription: \"Solve my specific physics challenge\"\n\ntarget_parameters:\n  coupling_strength:\n    symbol: g\n    target: \"> 5e9\"\n    units: Hz\n    description: \"Coupling strength parameter\"\n    weight: 0.5\n    type: optimization\n\nconstraints:\n  - name: energy_conservation\n    description: \"Energy must be conserved\"\n    type: fundamental\n    penalty_weight: 1.0\n\nbreakthrough_threshold: 0.9\nsignificant_progress_threshold: 0.75\ndifficulty_level: hard\n```\n\n### 2. Add to Problem Library\n```bash\n# Copy to problems directory\ncp my_custom_problem.yaml data/amo_problems/\n\n# Verify it loads correctly\npython src/main.py list-problems\npython src/main.py problem-info my_problem\n```\n\n### 3. Solve Your Custom Problem\n```bash\npython src/main.py solve-problem my_problem --generations 25\n```\n\n## Available AI Models\n\n| Model | Physics Expertise | Speed | Cost | Best For |\n|-------|------------------|-------|------|----------|\n| **Gemini 2.5 Flash** | High | Very Fast | Low | Exploration, testing |\n| **Claude 3.5 Sonnet** | Excellent | Fast | Medium | Complex physics, analysis |\n| **GPT-4 Turbo** | High | Medium | High | Structured solutions |\n\n### Model Selection Guide\n\n**For Learning/Testing:**\n```bash\npython src/main.py solve-problem room_temp_cavity_qed --demo\n```\n\n**For Exploration:**\n```bash\npython src/main.py solve-problem squeezed_light_20db --model \"provider-5/gemini-2.5-flash-preview-04-17\"\n```\n\n**For Deep Physics:**\n```bash\npython src/main.py solve-problem quantum_sensing_limit --model \"anthropic/claude-3.5-sonnet\"\n```\n\n## Contributing\n\nWe welcome contributions to expand Coheron's physics problem-solving capabilities!\n\n### Ways to Contribute\n\n1. **Add New Physics Problems**: Submit YAML files for unsolved physics challenges\n2. **Improve Physics Knowledge**: Expand the atomic data and experimental records database\n3. **Enhance Evaluation**: Improve physics validation and scoring algorithms\n4. **Cross-Platform Testing**: Test installation and usage on different OS configurations\n\n### Development Setup\n```bash\n# Fork and clone your fork\ngit clone https://github.com/yourusername/Coheron.git\ncd Coheron\n\n# Create development environment\npython -m venv dev-env\nsource dev-env/bin/activate  # Linux/macOS\npip install -r requirements.txt\npip install -r requirements-dev.txt  # Development dependencies\n\n# Run tests\npython -m pytest tests/\npython src/main.py test --all\n```\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## Support\n\n- **Issues**: Report bugs and request features on [GitHub Issues](https://github.com/manasp21/Coheron/issues)\n- **Discussions**: Ask questions and share results in [GitHub Discussions](https://github.com/manasp21/Coheron/discussions)\n- **Documentation**: See source code and comments for detailed technical information\n\n## Acknowledgments\n\n- **Quantum Optics Community**: For providing experimental benchmarks and validation data\n- **A4F Platform**: For flexible access to multiple AI models\n- **Open Source Community**: For Python packages that make this possible\n\n---\n\n## Ready to Solve Physics Problems?\n\n```bash\n# Quick start - try it now!\ngit clone <repository-url>\ncd Coheron\npip install -r requirements.txt\n\n# See what problems you can solve\npython src/main.py list-problems\n\n# Start solving (no API key needed for demo)\npython src/main.py solve-problem room_temp_cavity_qed --demo --generations 15\n```\n\n**Transform physics challenges into breakthrough solutions with evolutionary AI!**\n",
    "cached_at": 1752302468.321597
  },
  "https://github.com/manasp21/rabi-mcp": {
    "name": "rabi-mcp",
    "full_name": "manasp21/rabi-mcp",
    "description": "Advanced MCP server specialized in Atomic, Molecular and Optical (AMO) Physics",
    "readme_description": "Atomic, Molecular and Optical (AMO) Physics MCP Server Rabi MCP Server is a Model Context Protocol (MCP) server that provides essential quantum physics simulation tools for Claude and other AI assi...",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-06-26T06:21:28Z",
    "updated_at": "2025-06-28T14:01:35Z",
    "pushed_at": "2025-06-28T14:01:32Z",
    "size": 223,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/rabi-mcp",
    "clone_url": "https://github.com/manasp21/rabi-mcp.git",
    "ssh_url": "git@github.com:manasp21/rabi-mcp.git",
    "readme_content": "# Rabi MCP Server\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Python 3.8+](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)\n[![Docker](https://img.shields.io/badge/docker-available-blue.svg)](https://hub.docker.com/)\n[![Smithery](https://img.shields.io/badge/smithery-deployable-green.svg)](https://smithery.ai/)\n[![smithery badge](https://smithery.ai/badge/@manasp21/rabi-mcp)](https://smithery.ai/server/@manasp21/rabi-mcp)\n\n**Atomic, Molecular and Optical (AMO) Physics MCP Server**\n\nRabi MCP Server is a Model Context Protocol (MCP) server that provides essential quantum physics simulation tools for Claude and other AI assistants. Named after the Rabi oscillations fundamental to quantum optics, this server offers 5 core tools for simulating basic quantum systems and analyzing AMO physics phenomena.\n\n## Core Features\n\n### Available Physics Tools (5)\n\n**1. Two-Level Atom Simulation**\n- Simulates quantum dynamics of two-level atomic systems\n- Real-time population dynamics and coherence effects\n- Rabi frequency and detuning parameter control\n\n**2. Rabi Oscillations Analysis**\n- Calculates coherent oscillations between atomic energy levels\n- On-resonance and off-resonance behavior\n- Time-resolved population transfer analysis\n\n**3. Bose-Einstein Condensate (BEC) Simulation**\n- Basic BEC dynamics using simplified Gross-Pitaevskii equation\n- Particle interactions and quantum statistics\n- Characteristic length scales and energy analysis\n\n**4. Absorption Spectrum Calculation**\n- Spectral line analysis with natural and Doppler broadening\n- Temperature-dependent linewidth effects\n- Lorentzian and Gaussian profile modeling\n\n**5. Cavity QED Simulation**\n- Basic cavity quantum electrodynamics using Jaynes-Cummings model\n- Atom-photon coupling dynamics\n- Strong and weak coupling regime analysis\n\n## Installation Methods\n\nChoose your preferred installation method below. All methods give you access to the same 5 core AMO physics tools.\n\n### Method 1: Smithery Cloud (Recommended)\n\n**Deploy directly to the cloud with zero local setup:**\n\n```bash\n# Deploy to Smithery cloud\nnpx @smithery/cli deploy https://github.com/manasp21/rabi-mcp.git\n```\n\n**What you get:**\n- Instant cloud deployment (no local setup needed)\n- Automatic scaling and resource management\n- Built-in configuration management\n- 5 core physics tools ready to use\n- Integration with Claude and other AI assistants\n\n**Deployment Process:**\n1. **Deploy**: Run the deploy command above\n2. **Wait**: Deployment typically takes 2-5 minutes\n3. **Verify**: Check deployment status in Smithery dashboard\n4. **Test**: Server will be accessible once deployment completes\n\n### Method 2: Manual Installation\n\n**For local development and testing:**\n\n```bash\n# Clone repository\ngit clone https://github.com/manasp21/rabi-mcp.git\ncd rabi-mcp\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install --upgrade pip\npip install -r requirements.txt\n\n# Test the server\npython run_simple_server.py\n```\n\n---\n\n### Method 3: Docker\n\n**Build and run with Docker:**\n\n```bash\n# Clone and build\ngit clone https://github.com/manasp21/rabi-mcp.git\ncd rabi-mcp\ndocker build -t rabi-mcp-server .\ndocker run -p 8000:8000 rabi-mcp-server\n```\n\n---\n\n## Testing Your Installation\n\n### Quick Test\n\nAfter installation, test with:\n\n```bash\n# Test basic server functionality\ncurl http://localhost:8000/health\n\n# Or test a physics calculation\npython -c \"\nimport sys\nsys.path.append('src')\nfrom http_server import execute_physics_tool\nresult = execute_physics_tool('simulate_two_level_atom', {\n    'rabi_frequency': 1e6, \n    'detuning': 0, \n    'evolution_time': 1e-6\n})\nprint('Test passed!' if result['success'] else 'Test failed!')\n\"\n```\n\n## Configuration\n\nBasic configuration via environment variables:\n```bash\nexport PORT=8000\nexport HOST=0.0.0.0\nexport LOG_LEVEL=INFO\n```\n\n## Usage Examples\n\n### Tool 1: Two-Level Atom Simulation\n```python\n{\n    \"rabi_frequency\": 1000000,  # 1 MHz in rad/s\n    \"detuning\": 0,              # On resonance\n    \"evolution_time\": 0.000001  # 1 Œºs\n}\n```\n\n### Tool 2: Rabi Oscillations\n```python\n{\n    \"rabi_frequency\": 2000000,  # 2 MHz in rad/s\n    \"max_time\": 0.00001,        # 10 Œºs\n    \"time_points\": 1000\n}\n```\n\n### Tool 3: BEC Simulation\n```python\n{\n    \"particle_number\": 1000,\n    \"scattering_length\": 5.29,  # Bohr radii\n    \"trap_frequency\": 100       # Hz\n}\n```\n\n### Tool 4: Absorption Spectrum\n```python\n{\n    \"transition_frequency\": 3.8e15,  # rad/s\n    \"linewidth\": 6.07e6,             # rad/s\n    \"temperature\": 300               # Kelvin\n}\n```\n\n### Tool 5: Cavity QED\n```python\n{\n    \"coupling_strength\": 1000000,   # 1 MHz in rad/s\n    \"cavity_frequency\": 3.8e15,     # rad/s\n    \"atom_frequency\": 3.8e15        # rad/s\n}\n```\n\n## Available Tools (5)\n\n1. **`simulate_two_level_atom`** - Two-level quantum system dynamics\n2. **`rabi_oscillations`** - Coherent population oscillations\n3. **`bec_simulation`** - Bose-Einstein condensate physics\n4. **`absorption_spectrum`** - Spectral line analysis\n5. **`cavity_qed`** - Atom-cavity coupling dynamics\n\n## Contributing\n\nContributions welcome! Please submit issues and pull requests on GitHub.\n\n## License\n\nMIT License - see [LICENSE](LICENSE) file for details.\n\n## Acknowledgments\n\n- **NumPy/SciPy**: Scientific computing foundation\n- **MCP Protocol**: Model Context Protocol standard\n- **AMO Physics Community**: Physics knowledge base\n\n---\n\n<div align=\"center\">\n\n**Rabi MCP Server - AMO Physics Tools**\n\n[Get Started](https://github.com/manasp21/rabi-mcp) ‚Ä¢ [Issues](https://github.com/manasp21/rabi-mcp/issues)\n\n</div>",
    "cached_at": 1752302471.5208697
  },
  "https://github.com/manasp21/EventHorizon": {
    "name": "EventHorizon",
    "full_name": "manasp21/EventHorizon",
    "description": "An MCP server implementation that provides evolutionary solution generation and optimization capabilities for LLMs. Event Horizon enables LLMs to evolve solutions across multiple generations using consistency check evaluations and genetic algorithm principles.",
    "readme_description": "An MCP server implementation that provides evolutionary solution generation and optimization capabilities for LLMs. Event Horizon enables LLMs to evolve solutions across multiple generations using ...",
    "language": "JavaScript",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": "MIT License",
    "created_at": "2025-06-29T22:23:23Z",
    "updated_at": "2025-07-03T23:26:47Z",
    "pushed_at": "2025-07-03T23:26:45Z",
    "size": 5692,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/EventHorizon",
    "clone_url": "https://github.com/manasp21/EventHorizon.git",
    "ssh_url": "git@github.com:manasp21/EventHorizon.git",
    "readme_content": "# Event Horizon MCP Server\n\n[![Smithery](https://img.shields.io/badge/Smithery-Available-blue?style=flat&logo=smithery)](https://smithery.ai)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![TypeScript](https://img.shields.io/badge/TypeScript-Ready-blue.svg)](https://www.typescriptlang.org/)\n\nAn MCP server implementation that provides evolutionary solution generation and optimization capabilities for LLMs. Event Horizon enables LLMs to evolve solutions across multiple generations using consistency check evaluations and genetic algorithm principles.\n\n## Features\n\n- **Multi-generational Evolution**: Evolve solutions across multiple generations\n- **Consistency Check Evaluation**: Score solutions against multiple criteria\n- **Crossover Analysis**: Identify best aspects from different solutions\n- **Convergence Detection**: Automatically detect when solutions reach optimal scores\n- **Progress Tracking**: Monitor evolution progress and statistics\n- **Flexible Configuration**: Customize population size, generations, and thresholds\n\n## How It Works\n\n1. **Initialize Evolution**: Define a problem statement and consistency checks\n2. **Generate Population**: Create initial solutions for generation 0\n3. **Evaluate Solutions**: Score each solution against all consistency checks\n4. **Evolution Analysis**: Identify best-performing aspects per consistency check\n5. **Crossover Guidance**: Get recommendations for combining best aspects\n6. **Next Generation**: Create new solutions based on crossover recommendations\n7. **Repeat**: Continue until convergence or max generations reached\n\n## Tools\n\n### start_evolution\n\nInitialize an evolutionary solution system with a problem and consistency checks.\n\n**Parameters:**\n- `problemStatement` (string): The problem or challenge to solve\n- `consistencyChecks` (array): Array of evaluation criteria (strings or objects with description/weight)\n- `populationSize` (integer, optional): Solutions per generation (default: 3)\n- `maxGenerations` (integer, optional): Maximum generations (default: 5)\n- `convergenceThreshold` (number, optional): Score threshold for completion (default: 0.95)\n\n### add_solution\n\nAdd a new solution to the current generation.\n\n**Parameters:**\n- `content` (string): The solution content addressing the problem\n- `parentSolutions` (array, optional): Parent solution IDs if this is a crossover\n\n### score_solution\n\nScore a solution against a specific consistency check.\n\n**Parameters:**\n- `solutionId` (string): ID of the solution to score\n- `checkId` (string): ID of the consistency check\n- `score` (number): Score between 0.0 and 1.0\n- `reasoning` (string, optional): Explanation of the scoring rationale\n\n### evolve_generation\n\nEvolve to the next generation using crossover analysis.\n\nReturns crossover recommendations identifying the best-performing solution for each consistency check and guidance for creating new solutions.\n\n### get_evolution_status\n\nGet the current status of the evolutionary system including progress, statistics, and best solution found.\n\n## Installation\n\n### Smithery (Recommended)\n\nInstall directly from the Smithery registry for the easiest setup:\n\n```bash\nnpx @smithery/cli install event-horizon --client claude\n```\n\nThis automatically configures the server for Claude Desktop. You can also customize the installation:\n\n```bash\nnpx @smithery/cli install event-horizon --client claude --config '{\"disableLogging\": true, \"populationSize\": 5}'\n```\n\n### Manual Installation\n\nIf you prefer manual installation, add this to your `claude_desktop_config.json`:\n\n```json\n{\n  \"mcpServers\": {\n    \"event-horizon\": {\n      \"command\": \"node\",\n      \"args\": [\n        \"/path/to/EventHorizon/dist/index.js\"\n      ]\n    }\n  }\n}\n```\n\n### Clone and Build\n\nFor development or customization:\n\n```bash\ngit clone https://github.com/manasp21/EventHorizon.git\ncd EventHorizon\nnpm install\nnpm run build\n```\n\n## Advanced Configuration\n\n### Configuration Options\n\nThe Event Horizon server supports several configuration options:\n\n- `disableLogging` (boolean): Disable evolution progress logging (default: false)\n- `populationSize` (integer): Default population size for generations (default: 3)\n- `maxGenerations` (integer): Default maximum generations (default: 5)\n- `convergenceThreshold` (number): Default convergence threshold (default: 0.95)\n\n### Docker\n\nBuild and run with Docker:\n\n```bash\ndocker build -t event-horizon-mcp .\ndocker run --rm -i event-horizon-mcp\n```\n\nOr use in Claude Desktop config:\n\n```json\n{\n  \"mcpServers\": {\n    \"event-horizon\": {\n      \"command\": \"docker\",\n      \"args\": [\n        \"run\",\n        \"--rm\",\n        \"-i\",\n        \"event-horizon-mcp\"\n      ]\n    }\n  }\n}\n```\n\n### VS Code & Other MCP Clients\n\nFor other MCP clients, you can use Smithery CLI or manual configuration. Check the [Smithery documentation](https://smithery.ai/docs) for client-specific instructions.\n\n## Usage Example\n\nHere's a typical evolutionary workflow:\n\n### 1. Start Evolution\n\n```json\n{\n  \"tool\": \"start_evolution\",\n  \"arguments\": {\n    \"problemStatement\": \"Design an efficient sorting algorithm\",\n    \"consistencyChecks\": [\n      \"Algorithm must have optimal time complexity\",\n      \"Implementation must be memory efficient\",\n      \"Code must be readable and maintainable\"\n    ],\n    \"populationSize\": 3,\n    \"maxGenerations\": 5\n  }\n}\n```\n\n### 2. Add Initial Solutions\n\n```json\n{\n  \"tool\": \"add_solution\",\n  \"arguments\": {\n    \"content\": \"Implement quicksort with random pivot selection...\"\n  }\n}\n```\n\n### 3. Score Solutions\n\n```json\n{\n  \"tool\": \"score_solution\",\n  \"arguments\": {\n    \"solutionId\": \"generated_solution_id\",\n    \"checkId\": \"check_1\",\n    \"score\": 0.8\n  }\n}\n```\n\n### 4. Evolve Generation\n\n```json\n{\n  \"tool\": \"evolve_generation\",\n  \"arguments\": {}\n}\n```\n\nThe system will provide crossover recommendations like:\n```json\n{\n  \"crossoverRecommendations\": [\n    {\n      \"checkId\": \"check_1\",\n      \"bestSolutionId\": \"solution_a\",\n      \"score\": 0.9,\n      \"relevantContent\": \"Use random pivot selection for optimal performance...\"\n    }\n  ]\n}\n```\n\n### 5. Create Next Generation\n\nBased on recommendations, create new solutions combining the best aspects from previous generation.\n\n## Environment Variables\n\n- `DISABLE_EVOLUTION_LOGGING`: Set to `\"true\"` to disable progress logging\n\n## Building\n\n```bash\nnpm run build\nnpm run prepare\n```\n\n## Docker\n\n```bash\ndocker build -t mcp/event-horizon -f Dockerfile .\n```\n\n## Example Use Cases\n\n- **Algorithm Design**: Evolve optimal algorithms for specific problems\n- **Code Optimization**: Improve code performance across multiple metrics\n- **Creative Writing**: Evolve stories or content meeting multiple criteria\n- **Problem Solving**: Generate solutions optimized for multiple constraints\n- **System Design**: Evolve architectural solutions balancing various requirements\n\n## License\n\nThis MCP server is licensed under the MIT License. This means you are free to use, modify, and distribute the software, subject to the terms and conditions of the MIT License.",
    "cached_at": 1752302474.7270653
  },
  "https://github.com/manasp21/Omnitooth": {
    "name": "Omnitooth",
    "full_name": "manasp21/Omnitooth",
    "description": "A modern Windows desktop application that captures local keyboard and mouse input and transmits it wirelessly over Bluetooth to connected client devices",
    "readme_description": "A modern Windows desktop application that captures local keyboard and mouse input and transmits it wirelessly over Bluetooth to connected client devices. The Windows machine appears as a standard B...",
    "language": "C#",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-07-01T15:50:26Z",
    "updated_at": "2025-07-02T22:53:26Z",
    "pushed_at": "2025-07-02T22:53:23Z",
    "size": 145,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/Omnitooth",
    "clone_url": "https://github.com/manasp21/Omnitooth.git",
    "ssh_url": "git@github.com:manasp21/Omnitooth.git",
    "readme_content": "# Omnitooth - Bluetooth HID Emulator\n\nA modern Windows desktop application that captures local keyboard and mouse input and transmits it wirelessly over Bluetooth to connected client devices. The Windows machine appears as a standard Bluetooth Human Interface Device (HID) using Bluetooth Low Energy (BLE) with HID over GATT Profile (HOGP).\n\n## Features\n\n- **Zero-client software requirement**: Works with any device supporting Bluetooth HID\n- **Low-latency input transmission**: Optimized for gaming and professional use\n- **Multi-device support**: Connect multiple client devices simultaneously\n- **Security-first design**: Encrypted connections with proper authentication\n- **Modern UI/UX**: Intuitive WPF interface with real-time status monitoring\n\n## Technology Stack\n\n- **Framework**: .NET 8\n- **UI**: WPF with ModernWPF styling\n- **Architecture**: Clean Architecture with MVVM pattern\n- **Input Capture**: GameInput API (with Raw Input fallback)\n- **Bluetooth**: WinRT Bluetooth LE APIs\n- **Configuration**: Microsoft.Extensions.Configuration with appsettings.json\n- **Logging**: Serilog with structured logging\n- **Testing**: xUnit, Moq, FluentAssertions\n\n## Project Structure\n\n```\nOmnitooth/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ Omnitooth.Core/           # Domain models & interfaces\n‚îÇ   ‚îú‚îÄ‚îÄ Omnitooth.Infrastructure/ # Bluetooth, Input, HID implementation\n‚îÇ   ‚îú‚îÄ‚îÄ Omnitooth.Application/    # Services, Commands, Handlers\n‚îÇ   ‚îî‚îÄ‚îÄ Omnitooth.Presentation/   # WPF UI\n‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îú‚îÄ‚îÄ Omnitooth.Core.Tests/\n‚îÇ   ‚îú‚îÄ‚îÄ Omnitooth.Infrastructure.Tests/\n‚îÇ   ‚îî‚îÄ‚îÄ Omnitooth.Application.Tests/\n‚îú‚îÄ‚îÄ docs/\n‚îî‚îÄ‚îÄ plan.md                       # Development plan\n```\n\n## Requirements\n\n- Windows 11 22H2+ (for modern Windows APIs and GameInput support)\n- Bluetooth 4.0+ (required for BLE functionality)\n- .NET 8 Runtime\n- Administrator Rights (for system-level input capture)\n\n## Development Status\n\n### Phase 1: Foundation & Project Setup ‚úÖ\n- [x] Solution structure and directories\n- [x] .NET 8 projects (Core, Infrastructure, Application, Presentation)\n- [x] Central package management (Directory.Packages.props)\n- [x] Development tools (EditorConfig, Global.json)\n- [x] Dependency injection and configuration infrastructure\n- [x] Test projects structure\n\n### Phase 2: Advanced Input Capture System (Planned)\n- [ ] GameInput API integration\n- [ ] Raw Input fallback implementation\n- [ ] Input processing pipeline\n- [ ] Performance optimizations\n\n### Phase 3: HID Protocol Implementation (Planned)\n- [ ] HID Report descriptors\n- [ ] Report builder system\n- [ ] Multi-device support\n\n### Phase 4: Bluetooth GATT Server (Planned)\n- [ ] GATT service provider\n- [ ] HID service characteristics\n- [ ] Connection management\n\n### Phase 5: WPF Application (In Progress)\n- [x] Basic WPF application structure\n- [x] Main window with placeholder functionality\n- [ ] MVVM implementation with ViewModels\n- [ ] Settings and configuration UI\n\n### Phase 6: Testing & Quality Assurance (Planned)\n- [ ] Unit tests\n- [ ] Integration tests\n- [ ] End-to-end tests\n\n## Building\n\n```bash\ndotnet restore\ndotnet build\n```\n\n## Running\n\n```bash\ndotnet run --project src/Omnitooth.Presentation\n```\n\n## Configuration\n\nConfiguration is managed through `appsettings.json` and `appsettings.Development.json` files. Key configuration sections include:\n\n- **Bluetooth**: Device name, service UUID, connection settings\n- **Input**: GameInput preferences, sensitivity, rate limiting\n- **HID**: Report rates, batching, compression\n- **Security**: Authentication, encryption, device filtering\n- **Performance**: Threading, memory management\n- **UI**: Theme, startup behavior, notifications\n\n## License\n\nCopyright ¬© 2024 Omnitooth\n\n## Contributing\n\nThis project follows clean architecture principles and modern .NET development practices. Please ensure all code follows the established patterns and includes appropriate tests.",
    "cached_at": 1752302477.954984
  },
  "https://github.com/manasp21/Psi-MCP": {
    "name": "Psi-MCP",
    "full_name": "manasp21/Psi-MCP",
    "description": "An Advanced Quantum Physics MCP server",
    "readme_description": "The most comprehensive quantum physics MCP server for complex open and closed quantum systems calculations",
    "language": "Python",
    "stars": 0,
    "forks": 0,
    "watchers": 0,
    "open_issues": 0,
    "topics": [],
    "homepage": "",
    "license": null,
    "created_at": "2025-06-25T19:19:26Z",
    "updated_at": "2025-06-26T06:21:55Z",
    "pushed_at": "2025-06-26T06:21:52Z",
    "size": 72,
    "default_branch": "main",
    "html_url": "https://github.com/manasp21/Psi-MCP",
    "clone_url": "https://github.com/manasp21/Psi-MCP.git",
    "ssh_url": "git@github.com:manasp21/Psi-MCP.git",
    "readme_content": "# Psi-MCP: Advanced Quantum Systems MCP Server\n\n<div align=\"center\">\n\n![Quantum Computing](https://img.shields.io/badge/Quantum-Computing-blue?style=for-the-badge)\n![MCP Server](https://img.shields.io/badge/MCP-Server-green?style=for-the-badge)\n![Smithery Compatible](https://img.shields.io/badge/Smithery-Compatible-purple?style=for-the-badge)\n![Python](https://img.shields.io/badge/Python-3.11+-red?style=for-the-badge)\n\n*The most comprehensive quantum physics MCP server for complex open and closed quantum systems calculations*\n\n</div>\n\n## üåü Overview\n\nPsi-MCP is an advanced Model Context Protocol (MCP) server specifically designed for quantum systems analysis and simulation. It provides comprehensive tools for quantum computing, quantum chemistry, many-body physics, quantum machine learning, and quantum field theory calculations.\n\n### Key Features\n\n- üî¨ **Quantum Circuit Operations**: Create, simulate, optimize, and visualize quantum circuits\n- ‚öõÔ∏è **Open Quantum Systems**: Solve master equations, analyze decoherence, compute steady states\n- üß™ **Quantum Chemistry**: Molecular Hamiltonians, VQE, electronic structure calculations\n- üîó **Many-Body Physics**: DMRG, tensor networks, phase transitions, correlation functions\n- ü§ñ **Quantum Machine Learning**: QNNs, variational classifiers, quantum kernels\n- üåä **Quantum Field Theory**: Field quantization, path integrals, RG flow, anomalies\n- üìä **Advanced Visualization**: Bloch spheres, density matrices, Wigner functions\n- üöÄ **Smithery Compatible**: Easy deployment and integration\n\n## üõ† Installation\n\n### Prerequisites\n\n- Python 3.11 or higher\n- Docker (for containerized deployment)\n- Git\n\n### Core vs Optional Dependencies\n\n**Core Dependencies (always installed):**\n- FastAPI, Uvicorn (MCP server framework)\n- Qiskit, Cirq, PennyLane (quantum computing)\n- QuTiP (open quantum systems)\n- OpenFermion (quantum chemistry)\n- NumPy, SciPy, Matplotlib (numerical computing)\n\n**Optional Dependencies (install separately if needed):**\n- PySCF (advanced quantum chemistry)\n- TensorFlow Quantum (quantum ML)\n- NetKet (neural quantum states)\n- Additional quantum libraries\n\n### Quick Start with Smithery\n\n```bash\n# Install via Smithery CLI\nnpx @smithery/cli install psi-mcp --client cursor\n\n# Or deploy via GitHub integration\ngit clone https://github.com/manasp21/Psi-MCP.git\ncd Psi-MCP\n# Push to your GitHub repository and connect to Smithery\n```\n\n### Local Development\n\n```bash\n# Clone the repository\ngit clone https://github.com/manasp21/Psi-MCP.git\ncd Psi-MCP\n\n# Install dependencies\npip install -r requirements.txt\n\n# Run the server\npython src/server.py\n```\n\n### Docker Deployment\n\n```bash\n# Build the container\ndocker build -t psi-mcp .\n\n# Run with configuration\ndocker run -p 8000:8000 \\\n  -e computing_backend=simulator \\\n  -e max_qubits=20 \\\n  -e precision=double \\\n  psi-mcp\n```\n\n## üîß Configuration\n\n### Smithery Configuration\n\nConfigure via the Smithery dashboard or query parameters:\n\n```yaml\ncomputing_backend: \"simulator\"  # qasm_simulator, statevector_simulator\nmax_qubits: 20                  # Maximum qubits (1-30)\nprecision: \"double\"             # single, double, extended\nenable_gpu: false               # GPU acceleration\ntimeout_seconds: 300            # Calculation timeout\nmemory_limit_gb: 4              # Memory limit\n```\n\n### Environment Variables\n\n```bash\nPORT=8000                       # Server port\nHOST=0.0.0.0                   # Server host\nCOMPUTING_BACKEND=simulator     # Default backend\nMAX_QUBITS=20                  # Default max qubits\n```\n\n## üöÄ Usage\n\n### Quantum Circuit Operations\n\n#### Create Quantum Circuits\n\n```python\n# Create a Bell state circuit\ncreate_quantum_circuit(\n    num_qubits=2,\n    circuit_type=\"bell\",\n    backend=\"qasm_simulator\"\n)\n\n# Create a GHZ state\ncreate_quantum_circuit(\n    num_qubits=4,\n    circuit_type=\"ghz\",\n    backend=\"statevector_simulator\"\n)\n\n# Create quantum Fourier transform\ncreate_quantum_circuit(\n    num_qubits=3,\n    circuit_type=\"qft\",\n    backend=\"simulator\"\n)\n```\n\n#### Simulate Circuits\n\n```python\n# Simulate with measurements\nsimulate_quantum_circuit(\n    circuit_definition=\"circuit_1\",\n    shots=1024,\n    backend=\"qasm_simulator\"\n)\n\n# Get statevector\nsimulate_quantum_circuit(\n    circuit_definition=\"circuit_2\",\n    shots=1,\n    backend=\"statevector_simulator\"\n)\n```\n\n#### Optimize Circuits\n\n```python\n# Optimize for specific backend\noptimize_quantum_circuit(\n    circuit_definition=\"circuit_1\",\n    optimization_level=2,\n    target_backend=\"qasm_simulator\"\n)\n```\n\n### Open Quantum Systems\n\n#### Master Equation Solving\n\n```python\n# Solve Lindblad master equation\nsolve_master_equation(\n    hamiltonian=\"pauli_z\",\n    collapse_operators=\"spontaneous_emission\",\n    initial_state=\"excited\",\n    time_span=\"0,10,100\",\n    solver_method=\"mesolve\"\n)\n\n# Analyze decoherence\nanalyze_decoherence(\n    system_hamiltonian=\"pauli_x\",\n    environment_coupling=\"dephasing\",\n    temperature=0.1,\n    analysis_type=\"dephasing\"\n)\n```\n\n### Quantum Chemistry\n\n#### Molecular Calculations\n\n```python\n# Generate molecular Hamiltonian\ngenerate_molecular_hamiltonian(\n    molecule=\"H2\",\n    basis=\"sto-3g\",\n    charge=0,\n    multiplicity=1\n)\n\n# Run VQE for electronic structure\nvqe_chemistry(\n    molecule=\"H2O\",\n    basis=\"6-31g\",\n    ansatz=\"uccsd\",\n    optimizer=\"cobyla\"\n)\n\n# Simulate chemical reactions\nsimulate_chemical_reaction(\n    reactants=[\"H2\", \"O2\"],\n    products=[\"H2O\"],\n    method=\"vqe\"\n)\n```\n\n### Quantum Algorithms\n\n#### Shor's Algorithm\n\n```python\n# Factor integers\nshors_algorithm(\n    N=15,\n    backend=\"qasm_simulator\",\n    shots=1024\n)\n```\n\n#### Grover's Search\n\n```python\n# Search marked items\ngrovers_search(\n    marked_items=[3, 7],\n    search_space_size=16,\n    backend=\"simulator\"\n)\n```\n\n#### VQE Optimization\n\n```python\n# Variational quantum eigensolver\nvqe_optimization(\n    hamiltonian=\"ising\",\n    ansatz_type=\"ry\",\n    optimizer=\"cobyla\",\n    max_iterations=100\n)\n```\n\n### Many-Body Physics\n\n#### DMRG Simulations\n\n```python\n# Run DMRG for spin chains\ndmrg_simulation(\n    hamiltonian_type=\"heisenberg\",\n    system_size=20,\n    bond_dimension=100,\n    max_sweeps=10\n)\n\n# Phase transition analysis\nphase_transition_analysis(\n    model_type=\"ising\",\n    parameter_range=[0.0, 2.0],\n    n_points=20,\n    system_size=16\n)\n```\n\n### Quantum Machine Learning\n\n#### Neural Networks\n\n```python\n# Train quantum neural network\nquantum_neural_network(\n    input_data=[[0.1, 0.2], [0.3, 0.4]],\n    labels=[0, 1],\n    n_qubits=4,\n    n_layers=2,\n    epochs=50\n)\n\n# Variational classifier\nvariational_classifier(\n    training_data=train_X,\n    training_labels=train_y,\n    test_data=test_X,\n    ansatz_type=\"hardware_efficient\"\n)\n```\n\n### Visualization\n\n#### Quantum States\n\n```python\n# Bloch sphere visualization\nvisualize_quantum_state(\n    state_definition=\"superposition\",\n    visualization_type=\"bloch_sphere\"\n)\n\n# Density matrix plot\nvisualize_quantum_state(\n    state_definition=\"bell\",\n    visualization_type=\"density_matrix\"\n)\n\n# Wigner function\nvisualize_quantum_state(\n    state_definition=\"coherent\",\n    visualization_type=\"wigner_function\"\n)\n```\n\n## üìö API Reference\n\n### Core Tools\n\n| Tool Name | Description | Parameters |\n|-----------|-------------|------------|\n| `create_quantum_circuit` | Create quantum circuits | `num_qubits`, `circuit_type`, `backend` |\n| `simulate_quantum_circuit` | Simulate circuits | `circuit_definition`, `shots`, `backend` |\n| `solve_master_equation` | Solve open system dynamics | `hamiltonian`, `collapse_operators`, `initial_state` |\n| `vqe_optimization` | Variational quantum eigensolver | `hamiltonian`, `ansatz_type`, `optimizer` |\n| `dmrg_simulation` | Many-body simulations | `hamiltonian_type`, `system_size`, `bond_dimension` |\n| `quantum_neural_network` | Train QNNs | `input_data`, `labels`, `n_qubits`, `n_layers` |\n\n### Supported Backends\n\n- **Qiskit**: `qasm_simulator`, `statevector_simulator`, `unitary_simulator`\n- **Cirq**: `cirq_simulator`\n- **PennyLane**: `default.qubit`, `default.qubit.torch`\n\n### Circuit Types\n\n- `empty`: Empty circuit\n- `bell`: Bell state preparation\n- `ghz`: GHZ state preparation\n- `qft`: Quantum Fourier transform\n- `random`: Random circuit\n\n## üèó Architecture\n\n```\nPsi-MCP/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ server.py              # Main MCP server\n‚îÇ   ‚îî‚îÄ‚îÄ quantum/               # Quantum modules\n‚îÇ       ‚îú‚îÄ‚îÄ __init__.py        # Backend initialization\n‚îÇ       ‚îú‚îÄ‚îÄ circuits.py        # Circuit operations\n‚îÇ       ‚îú‚îÄ‚îÄ systems.py         # Open quantum systems\n‚îÇ       ‚îú‚îÄ‚îÄ algorithms.py      # Quantum algorithms\n‚îÇ       ‚îú‚îÄ‚îÄ chemistry.py       # Quantum chemistry\n‚îÇ       ‚îú‚îÄ‚îÄ many_body.py       # Many-body physics\n‚îÇ       ‚îú‚îÄ‚îÄ field_theory.py    # Quantum field theory\n‚îÇ       ‚îú‚îÄ‚îÄ ml.py             # Quantum ML\n‚îÇ       ‚îú‚îÄ‚îÄ visualization.py   # Visualization tools\n‚îÇ       ‚îî‚îÄ‚îÄ utils.py          # Utility functions\n‚îú‚îÄ‚îÄ tests/                     # Test suite\n‚îú‚îÄ‚îÄ docs/                      # Documentation\n‚îú‚îÄ‚îÄ smithery.yaml             # Smithery configuration\n‚îú‚îÄ‚îÄ Dockerfile               # Container configuration\n‚îú‚îÄ‚îÄ requirements.txt         # Python dependencies\n‚îî‚îÄ‚îÄ README.md               # This file\n```\n\n## üß™ Examples\n\n### Complete Workflow Example\n\n```python\n# 1. Create and simulate a quantum circuit\ncircuit_result = create_quantum_circuit(\n    num_qubits=3,\n    circuit_type=\"ghz\",\n    backend=\"qasm_simulator\"\n)\n\n# 2. Simulate the circuit\nsimulation_result = simulate_quantum_circuit(\n    circuit_definition=circuit_result['id'],\n    shots=1000,\n    backend=\"qasm_simulator\"\n)\n\n# 3. Visualize the results\nplot_result = plot_measurement_results(\n    counts=simulation_result['counts'],\n    title=\"GHZ State Measurement\"\n)\n\n# 4. Analyze entanglement\nentropy = calculate_entanglement_entropy(\n    circuit_definition=circuit_result['id'],\n    subsystem_size=1\n)\n```\n\n### Quantum Chemistry Workflow\n\n```python\n# 1. Generate molecular Hamiltonian\nhamiltonian = generate_molecular_hamiltonian(\n    molecule=\"H2\",\n    basis=\"sto-3g\"\n)\n\n# 2. Run VQE calculation\nvqe_result = vqe_chemistry(\n    molecule=\"H2\",\n    basis=\"sto-3g\",\n    ansatz=\"uccsd\"\n)\n\n# 3. Compute molecular properties\nproperties = compute_molecular_properties(\n    molecule=\"H2\",\n    method=\"hf\",\n    basis=\"sto-3g\"\n)\n```\n\n## üî¨ Advanced Features\n\n### Custom Hamiltonians\n\n```python\n# Define custom spin chain\nsolve_master_equation(\n    hamiltonian=json.dumps([[1, 0], [0, -1]]),\n    collapse_operators=\"custom_operators\",\n    initial_state=\"custom_state\"\n)\n```\n\n### GPU Acceleration\n\n```python\n# Enable GPU support\nconfigure_server(\n    enable_gpu=True,\n    computing_backend=\"gpu_simulator\"\n)\n```\n\n### Parallel Processing\n\n```python\n# Parallel circuit simulation\nsimulate_circuits_parallel(\n    circuit_definitions=[\"circuit_1\", \"circuit_2\", \"circuit_3\"],\n    shots=1000\n)\n```\n\n## üìä Performance\n\n### Benchmarks\n\n| Operation | System Size | Execution Time | Memory Usage |\n|-----------|-------------|----------------|--------------|\n| Circuit Simulation | 20 qubits | ~2s | ~100MB |\n| VQE Optimization | H2O molecule | ~30s | ~200MB |\n| DMRG Calculation | 50 sites | ~60s | ~500MB |\n| QNN Training | 100 samples | ~45s | ~150MB |\n\n### Scaling\n\n- **Quantum Circuits**: Up to 30 qubits (simulator dependent)\n- **Many-Body Systems**: Up to 100 sites with DMRG\n- **Molecular Systems**: Up to 20 orbitals with VQE\n- **ML Training**: Up to 1000 samples efficiently\n\n## ü§ù Contributing\n\nWe welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.\n\n### Development Setup\n\n```bash\n# Clone and install development dependencies\ngit clone https://github.com/manasp21/Psi-MCP.git\ncd Psi-MCP\npip install -r requirements.txt\npip install -e .[dev]\n\n# Run tests\npytest tests/\n\n# Format code\nblack src/ tests/\nisort src/ tests/\n\n# Type checking\nmypy src/\n```\n\n## üìÑ License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## üôè Acknowledgments\n\n- **Qiskit Team** for quantum computing framework\n- **QuTiP Developers** for open quantum systems tools\n- **PennyLane Team** for quantum machine learning\n- **OpenFermion Contributors** for quantum chemistry tools\n- **Smithery Platform** for MCP server hosting\n\n## üìû Support\n\n- **GitHub Issues**: [Report bugs or request features](https://github.com/manasp21/Psi-MCP/issues)\n- **Documentation**: [Full API documentation](https://github.com/manasp21/Psi-MCP/docs)\n- **Examples**: [Jupyter notebooks with examples](https://github.com/manasp21/Psi-MCP/examples)\n\n## üó∫ Roadmap\n\n### v1.1.0 (Next Release)\n- [ ] ITensor integration for tensor networks\n- [ ] NetKet support for neural quantum states\n- [ ] Advanced error mitigation tools\n- [ ] Quantum error correction codes\n\n### v1.2.0 (Future)\n- [ ] Hardware backend support (IBM, Google, IonQ)\n- [ ] Advanced visualization dashboard\n- [ ] Quantum advantage benchmarks\n- [ ] Multi-user collaboration features\n\n---\n\n<div align=\"center\">\n\n**Built with ‚ù§Ô∏è for the quantum computing community**\n\n[üåü Star us on GitHub](https://github.com/manasp21/Psi-MCP) | [üìñ Read the Docs](https://github.com/manasp21/Psi-MCP/docs) | [üöÄ Deploy on Smithery](https://smithery.ai)\n\n</div>",
    "cached_at": 1752302481.153248
  }
}